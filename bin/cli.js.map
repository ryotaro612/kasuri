{
  "version": 3,
  "sources": ["../src/index.ts", "../src/args.ts", "../src/signin.ts", "../node_modules/.pnpm/jwt-decode@4.0.0/node_modules/jwt-decode/build/esm/index.js", "../node_modules/.pnpm/oidc-client-ts@3.3.0/node_modules/oidc-client-ts/src/utils/Logger.ts", "../node_modules/.pnpm/oidc-client-ts@3.3.0/node_modules/oidc-client-ts/src/utils/JwtUtils.ts", "../node_modules/.pnpm/oidc-client-ts@3.3.0/node_modules/oidc-client-ts/src/utils/CryptoUtils.ts", "../node_modules/.pnpm/oidc-client-ts@3.3.0/node_modules/oidc-client-ts/src/utils/Event.ts", "../node_modules/.pnpm/oidc-client-ts@3.3.0/node_modules/oidc-client-ts/src/utils/PopupUtils.ts", "../node_modules/.pnpm/oidc-client-ts@3.3.0/node_modules/oidc-client-ts/src/utils/Timer.ts", "../node_modules/.pnpm/oidc-client-ts@3.3.0/node_modules/oidc-client-ts/src/utils/UrlUtils.ts", "../node_modules/.pnpm/oidc-client-ts@3.3.0/node_modules/oidc-client-ts/src/errors/ErrorResponse.ts", "../node_modules/.pnpm/oidc-client-ts@3.3.0/node_modules/oidc-client-ts/src/errors/ErrorTimeout.ts", "../node_modules/.pnpm/oidc-client-ts@3.3.0/node_modules/oidc-client-ts/src/AccessTokenEvents.ts", "../node_modules/.pnpm/oidc-client-ts@3.3.0/node_modules/oidc-client-ts/src/CheckSessionIFrame.ts", "../node_modules/.pnpm/oidc-client-ts@3.3.0/node_modules/oidc-client-ts/src/InMemoryWebStorage.ts", "../node_modules/.pnpm/oidc-client-ts@3.3.0/node_modules/oidc-client-ts/src/errors/ErrorDPoPNonce.ts", "../node_modules/.pnpm/oidc-client-ts@3.3.0/node_modules/oidc-client-ts/src/JsonService.ts", "../node_modules/.pnpm/oidc-client-ts@3.3.0/node_modules/oidc-client-ts/src/MetadataService.ts", "../node_modules/.pnpm/oidc-client-ts@3.3.0/node_modules/oidc-client-ts/src/WebStorageStateStore.ts", "../node_modules/.pnpm/oidc-client-ts@3.3.0/node_modules/oidc-client-ts/src/OidcClientSettings.ts", "../node_modules/.pnpm/oidc-client-ts@3.3.0/node_modules/oidc-client-ts/src/UserInfoService.ts", "../node_modules/.pnpm/oidc-client-ts@3.3.0/node_modules/oidc-client-ts/src/TokenClient.ts", "../node_modules/.pnpm/oidc-client-ts@3.3.0/node_modules/oidc-client-ts/src/ResponseValidator.ts", "../node_modules/.pnpm/oidc-client-ts@3.3.0/node_modules/oidc-client-ts/src/State.ts", "../node_modules/.pnpm/oidc-client-ts@3.3.0/node_modules/oidc-client-ts/src/SigninState.ts", "../node_modules/.pnpm/oidc-client-ts@3.3.0/node_modules/oidc-client-ts/src/SigninRequest.ts", "../node_modules/.pnpm/oidc-client-ts@3.3.0/node_modules/oidc-client-ts/src/SigninResponse.ts", "../node_modules/.pnpm/oidc-client-ts@3.3.0/node_modules/oidc-client-ts/src/SignoutRequest.ts", "../node_modules/.pnpm/oidc-client-ts@3.3.0/node_modules/oidc-client-ts/src/SignoutResponse.ts", "../node_modules/.pnpm/oidc-client-ts@3.3.0/node_modules/oidc-client-ts/src/ClaimsService.ts", "../node_modules/.pnpm/oidc-client-ts@3.3.0/node_modules/oidc-client-ts/src/DPoPStore.ts", "../node_modules/.pnpm/oidc-client-ts@3.3.0/node_modules/oidc-client-ts/src/OidcClient.ts", "../node_modules/.pnpm/oidc-client-ts@3.3.0/node_modules/oidc-client-ts/src/SessionMonitor.ts", "../node_modules/.pnpm/oidc-client-ts@3.3.0/node_modules/oidc-client-ts/src/User.ts", "../node_modules/.pnpm/oidc-client-ts@3.3.0/node_modules/oidc-client-ts/src/navigators/AbstractChildWindow.ts", "../node_modules/.pnpm/oidc-client-ts@3.3.0/node_modules/oidc-client-ts/src/UserManagerSettings.ts", "../node_modules/.pnpm/oidc-client-ts@3.3.0/node_modules/oidc-client-ts/src/navigators/IFrameWindow.ts", "../node_modules/.pnpm/oidc-client-ts@3.3.0/node_modules/oidc-client-ts/src/navigators/IFrameNavigator.ts", "../node_modules/.pnpm/oidc-client-ts@3.3.0/node_modules/oidc-client-ts/src/navigators/PopupWindow.ts", "../node_modules/.pnpm/oidc-client-ts@3.3.0/node_modules/oidc-client-ts/src/navigators/PopupNavigator.ts", "../node_modules/.pnpm/oidc-client-ts@3.3.0/node_modules/oidc-client-ts/src/navigators/RedirectNavigator.ts", "../node_modules/.pnpm/oidc-client-ts@3.3.0/node_modules/oidc-client-ts/src/UserManagerEvents.ts", "../node_modules/.pnpm/oidc-client-ts@3.3.0/node_modules/oidc-client-ts/src/SilentRenewService.ts", "../node_modules/.pnpm/oidc-client-ts@3.3.0/node_modules/oidc-client-ts/src/RefreshState.ts", "../node_modules/.pnpm/oidc-client-ts@3.3.0/node_modules/oidc-client-ts/src/UserManager.ts", "../node_modules/.pnpm/oidc-client-ts@3.3.0/node_modules/oidc-client-ts/package.json", "../node_modules/.pnpm/oidc-client-ts@3.3.0/node_modules/oidc-client-ts/src/Version.ts", "../node_modules/.pnpm/oidc-client-ts@3.3.0/node_modules/oidc-client-ts/src/IndexedDbDPoPStore.ts", "../node_modules/.pnpm/open@10.2.0/node_modules/open/index.js", "../node_modules/.pnpm/wsl-utils@0.1.0/node_modules/wsl-utils/index.js", "../node_modules/.pnpm/is-wsl@3.1.0/node_modules/is-wsl/index.js", "../node_modules/.pnpm/is-inside-container@1.0.0/node_modules/is-inside-container/index.js", "../node_modules/.pnpm/is-docker@3.0.0/node_modules/is-docker/index.js", "../node_modules/.pnpm/define-lazy-prop@3.0.0/node_modules/define-lazy-prop/index.js", "../node_modules/.pnpm/default-browser@5.2.1/node_modules/default-browser/index.js", "../node_modules/.pnpm/default-browser-id@5.0.0/node_modules/default-browser-id/index.js", "../node_modules/.pnpm/run-applescript@7.0.0/node_modules/run-applescript/index.js", "../node_modules/.pnpm/bundle-name@4.1.0/node_modules/bundle-name/index.js", "../node_modules/.pnpm/default-browser@5.2.1/node_modules/default-browser/windows.js", "../src/main.ts"],
  "sourcesContent": ["#!/usr/bin/env -S node --enable-source-maps\n\nimport { argv } from \"node:process\";\nimport { main } from \"./main.ts\";\n\nmain(argv.slice(2)).then((exitCode) => {\n  if (exitCode !== 0) {\n    process.exit(exitCode);\n  }\n});\n", "import { existsSync, readFileSync } from \"node:fs\";\nimport { type ParseArgsOptionsType, parseArgs, parseEnv } from \"node:util\";\n\n/**\n *\n */\ninterface Command {\n  port: number;\n  oidcClientId: string;\n  clientSecret: string;\n  error: string | null;\n  help: boolean;\n}\n\n/**\n *\n * @param args\n * @returns\n */\nexport function parseCmdLine(args: string[]): Command {\n  const options = {\n    port: {\n      type: \"string\" as ParseArgsOptionsType,\n      short: \"p\",\n      default: \"36332\",\n    },\n    env: {\n      type: \"string\" as ParseArgsOptionsType,\n      short: \"e\",\n      default: \".env\",\n    },\n    help: {\n      type: \"boolean\" as ParseArgsOptionsType,\n      short: \"h\",\n      default: false,\n    },\n  };\n\n  const parsed = parseArgs({ args, options });\n  const envPath = parsed.values.env as string;\n  let env: NodeJS.Dict<string> = {};\n  if (existsSync(envPath)) {\n    env = readEnvFile(envPath);\n  }\n\n  let error = null;\n  const oidcClientId =\n    process.env.ASHITABA_OIDC_CLIENT_ID ?? env.ASHITABA_OIDC_CLIENT_ID;\n  if (!oidcClientId) {\n    error = \"Environment variable ASHITABA_OIDC_CLIENT_ID must be defined.\";\n  }\n  const oidClientSecret =\n    process.env.ASHITABA_OIDC_CLIENT_SECRET ?? env.ASHITABA_OIDC_CLIENT_SECRET;\n  if (!oidClientSecret) {\n    error = \"Environment variable ASHITABA_OIDC_CLIENT_SECRET must be defined.\";\n  }\n\n  return {\n    port: parseInt(parsed.values.port as string),\n    oidcClientId: oidcClientId ?? \"\",\n    clientSecret: oidClientSecret ?? \"\",\n    error,\n    help: parsed.values.help as boolean,\n  };\n}\n\n/**\n *\n */\nexport function helpMessage(): string {\n  return `\n\tUsage: ashitaba [options]\n\n\tOptions:\n\t  -p, --port <port>          Port to listen on (default: 36332)\n\t  -e, --env <env>            Path to the environment file (default: .env)\n\t  -h, --help                 Show this help message\n\t`;\n}\n\nfunction readEnvFile(envFilePath: string): NodeJS.Dict<string> {\n  const buffer = readFileSync(envFilePath);\n  return parseEnv(buffer.toString());\n}\n", "import {\n  createServer,\n  type IncomingMessage,\n  type ServerResponse,\n} from \"node:http\";\nimport { OidcClient } from \"oidc-client-ts\";\nimport open from \"open\";\n\n/**\n *\n */\nexport async function signIn({\n  clientId,\n  clientSecret,\n  port,\n}: {\n  clientId: string;\n  clientSecret: string;\n  port: number;\n}) {\n  const client = new OidcClient({\n    authority: \"https://accounts.google.com\",\n    client_id: clientId,\n    client_secret: clientSecret,\n    redirect_uri: `http://127.0.0.1:${port}/callback`,\n  });\n\n  const request = await client.createSigninRequest({});\n  await open(request.url);\n\n  const res: { data: undefined | string } = { data: undefined };\n  const server = runServer(port, res);\n\n  while (!res.data) {\n    await sleep(500);\n  }\n  server.close();\n  console.log(res.data);\n  const re = await client.processSigninResponse(res.data);\n  console.log(re);\n}\n\nfunction runServer(port: number, result: { data: undefined | string }) {\n  const server = createServer(\n    async (req: IncomingMessage, res: ServerResponse) => {\n      console.log(\"request: \", req.url);\n      //res.writeHead(302, { Location: req.url });\n      res.statusCode = 200;\n      result.data = `http://127.0.0.1:${port}${req.url}`;\n      // res.write('');\n      res.end();\n    }\n  );\n  return server.listen(port, () => {\n    // callback\n  });\n}\n\nfunction sleep(ms: number) {\n  return new Promise((res) => setTimeout(res, ms));\n}\n", "export class InvalidTokenError extends Error {\n}\nInvalidTokenError.prototype.name = \"InvalidTokenError\";\nfunction b64DecodeUnicode(str) {\n    return decodeURIComponent(atob(str).replace(/(.)/g, (m, p) => {\n        let code = p.charCodeAt(0).toString(16).toUpperCase();\n        if (code.length < 2) {\n            code = \"0\" + code;\n        }\n        return \"%\" + code;\n    }));\n}\nfunction base64UrlDecode(str) {\n    let output = str.replace(/-/g, \"+\").replace(/_/g, \"/\");\n    switch (output.length % 4) {\n        case 0:\n            break;\n        case 2:\n            output += \"==\";\n            break;\n        case 3:\n            output += \"=\";\n            break;\n        default:\n            throw new Error(\"base64 string is not of the correct length\");\n    }\n    try {\n        return b64DecodeUnicode(output);\n    }\n    catch (err) {\n        return atob(output);\n    }\n}\nexport function jwtDecode(token, options) {\n    if (typeof token !== \"string\") {\n        throw new InvalidTokenError(\"Invalid token specified: must be a string\");\n    }\n    options || (options = {});\n    const pos = options.header === true ? 0 : 1;\n    const part = token.split(\".\")[pos];\n    if (typeof part !== \"string\") {\n        throw new InvalidTokenError(`Invalid token specified: missing part #${pos + 1}`);\n    }\n    let decoded;\n    try {\n        decoded = base64UrlDecode(part);\n    }\n    catch (e) {\n        throw new InvalidTokenError(`Invalid token specified: invalid base64 for part #${pos + 1} (${e.message})`);\n    }\n    try {\n        return JSON.parse(decoded);\n    }\n    catch (e) {\n        throw new InvalidTokenError(`Invalid token specified: invalid json for part #${pos + 1} (${e.message})`);\n    }\n}\n", "// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\n/**\n * Native interface\n *\n * @public\n */\nexport interface ILogger {\n    debug(...args: unknown[]): void;\n    info(...args: unknown[]): void;\n    warn(...args: unknown[]): void;\n    error(...args: unknown[]): void;\n}\n\nconst nopLogger: ILogger = {\n    debug: () => undefined,\n    info: () => undefined,\n    warn: () => undefined,\n    error: () => undefined,\n};\n\nlet level: number;\nlet logger: ILogger;\n\n/**\n * Log levels\n *\n * @public\n */\nexport enum Log {\n    NONE,\n    ERROR,\n    WARN,\n    INFO,\n    DEBUG\n}\n\n/**\n * Log manager\n *\n * @public\n */\nexport namespace Log { // eslint-disable-line @typescript-eslint/no-namespace\n    export function reset(): void {\n        level = Log.INFO;\n        logger = nopLogger;\n    }\n\n    export function setLevel(value: Log): void {\n        if (!(Log.NONE <= value && value <= Log.DEBUG)) {\n            throw new Error(\"Invalid log level\");\n        }\n        level = value;\n    }\n\n    export function setLogger(value: ILogger): void {\n        logger = value;\n    }\n}\n\n/**\n * Internal logger instance\n *\n * @public\n */\nexport class Logger {\n    private _method?: string;\n    public constructor(private _name: string) {}\n\n    /* eslint-disable @typescript-eslint/no-unsafe-enum-comparison */\n    public debug(...args: unknown[]): void {\n        if (level >= Log.DEBUG) {\n            logger.debug(Logger._format(this._name, this._method), ...args);\n        }\n    }\n    public info(...args: unknown[]): void {\n        if (level >= Log.INFO) {\n            logger.info(Logger._format(this._name, this._method), ...args);\n        }\n    }\n    public warn(...args: unknown[]): void {\n        if (level >= Log.WARN) {\n            logger.warn(Logger._format(this._name, this._method), ...args);\n        }\n    }\n    public error(...args: unknown[]): void {\n        if (level >= Log.ERROR) {\n            logger.error(Logger._format(this._name, this._method), ...args);\n        }\n    }\n    /* eslint-enable @typescript-eslint/no-unsafe-enum-comparison */\n\n    public throw(err: Error): never {\n        this.error(err);\n        throw err;\n    }\n\n    public create(method: string): Logger {\n        const methodLogger: Logger = Object.create(this);\n        methodLogger._method = method;\n        methodLogger.debug(\"begin\");\n        return methodLogger;\n    }\n\n    public static createStatic(name: string, staticMethod: string): Logger {\n        const staticLogger = new Logger(`${name}.${staticMethod}`);\n        staticLogger.debug(\"begin\");\n        return staticLogger;\n    }\n\n    private static _format(name: string, method?: string) {\n        const prefix = `[${name}]`;\n        return method ? `${prefix} ${method}:` : prefix;\n    }\n\n    /* eslint-disable @typescript-eslint/no-unsafe-enum-comparison */\n    // helpers for static class methods\n    public static debug(name: string, ...args: unknown[]): void {\n        if (level >= Log.DEBUG) {\n            logger.debug(Logger._format(name), ...args);\n        }\n    }\n    public static info(name: string, ...args: unknown[]): void {\n        if (level >= Log.INFO) {\n            logger.info(Logger._format(name), ...args);\n        }\n    }\n    public static warn(name: string, ...args: unknown[]): void {\n        if (level >= Log.WARN) {\n            logger.warn(Logger._format(name), ...args);\n        }\n    }\n    public static error(name: string, ...args: unknown[]): void {\n        if (level >= Log.ERROR) {\n            logger.error(Logger._format(name), ...args);\n        }\n    }\n    /* eslint-enable @typescript-eslint/no-unsafe-enum-comparison */\n}\n\nLog.reset();\n", "import { jwtDecode } from \"jwt-decode\";\n\nimport { Logger } from \"./Logger\";\nimport type { JwtClaims } from \"../Claims\";\nimport { CryptoUtils } from \"./CryptoUtils\";\n\n/**\n * @internal\n */\nexport class JwtUtils {\n    // IMPORTANT: doesn't validate the token\n    public static decode(token: string): JwtClaims {\n        try {\n            return jwtDecode<JwtClaims>(token);\n        }\n        catch (err) {\n            Logger.error(\"JwtUtils.decode\", err);\n            throw err;\n        }\n    }\n\n    public static async generateSignedJwt(header: object, payload: object, privateKey: CryptoKey) : Promise<string> {\n        const encodedHeader = CryptoUtils.encodeBase64Url(new TextEncoder().encode(JSON.stringify(header)));\n        const encodedPayload = CryptoUtils.encodeBase64Url(new TextEncoder().encode(JSON.stringify(payload)));\n        const encodedToken = `${encodedHeader}.${encodedPayload}`;\n\n        const signature = await window.crypto.subtle.sign(\n            {\n                name: \"ECDSA\",\n                hash: { name: \"SHA-256\" },\n            },\n            privateKey,\n            new TextEncoder().encode(encodedToken),\n        );\n\n        const encodedSignature = CryptoUtils.encodeBase64Url(new Uint8Array(signature));\n        return `${encodedToken}.${encodedSignature}`;\n    }\n}\n", "import { Logger } from \"./Logger\";\nimport { JwtUtils } from \"./JwtUtils\";\n\nexport interface GenerateDPoPProofOpts {\n    url: string;\n    accessToken?: string;\n    httpMethod?: string;\n    keyPair: CryptoKeyPair;\n    nonce?: string;\n}\n\nconst UUID_V4_TEMPLATE = \"10000000-1000-4000-8000-100000000000\";\n\nconst toBase64 = (val: ArrayBuffer): string =>\n    btoa([...new Uint8Array(val)]\n        .map((chr) => String.fromCharCode(chr))\n        .join(\"\"));\n\n/**\n * @internal\n */\nexport class CryptoUtils {\n    private static _randomWord(): number {\n        const arr = new Uint32Array(1);\n        crypto.getRandomValues(arr);\n        return arr[0];\n    }\n\n    /**\n     * Generates RFC4122 version 4 guid\n     */\n    public static generateUUIDv4(): string {\n        const uuid = UUID_V4_TEMPLATE.replace(/[018]/g, c =>\n            (+c ^ CryptoUtils._randomWord() & 15 >> +c / 4).toString(16),\n        );\n        return uuid.replace(/-/g, \"\");\n    }\n\n    /**\n     * PKCE: Generate a code verifier\n     */\n    public static generateCodeVerifier(): string {\n        return CryptoUtils.generateUUIDv4() + CryptoUtils.generateUUIDv4() + CryptoUtils.generateUUIDv4();\n    }\n\n    /**\n     * PKCE: Generate a code challenge\n     */\n    public static async generateCodeChallenge(code_verifier: string): Promise<string> {\n        if (!crypto.subtle) {\n            throw new Error(\"Crypto.subtle is available only in secure contexts (HTTPS).\");\n        }\n\n        try {\n            const encoder = new TextEncoder();\n            const data = encoder.encode(code_verifier);\n            const hashed = await crypto.subtle.digest(\"SHA-256\", data);\n            return toBase64(hashed).replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=+$/, \"\");\n        }\n        catch (err) {\n            Logger.error(\"CryptoUtils.generateCodeChallenge\", err);\n            throw err;\n        }\n    }\n\n    /**\n     * Generates a base64-encoded string for a basic auth header\n     */\n    public static generateBasicAuth(client_id: string, client_secret: string): string {\n        const encoder = new TextEncoder();\n        const data = encoder.encode([client_id, client_secret].join(\":\"));\n        return toBase64(data);\n    }\n\n    /**\n     * Generates a hash of a string using a given algorithm\n     * @param alg\n     * @param message\n     */\n    public static async hash(alg: string, message: string) : Promise<Uint8Array> {\n        const msgUint8 = new TextEncoder().encode(message);\n        const hashBuffer = await crypto.subtle.digest(alg, msgUint8);\n        return new Uint8Array(hashBuffer);\n    }\n\n    /**\n     * Generates a base64url encoded string\n     */\n    public static encodeBase64Url = (input: Uint8Array) => {\n        return toBase64(input).replace(/=/g, \"\").replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\n    };\n\n    /**\n     * Generates a rfc7638 compliant jwk thumbprint\n     * @param jwk\n     */\n    public static async customCalculateJwkThumbprint(jwk: JsonWebKey): Promise<string> {\n        let jsonObject: object;\n        switch (jwk.kty) {\n            case \"RSA\":\n                jsonObject = {\n                    \"e\": jwk.e,\n                    \"kty\": jwk.kty,\n                    \"n\": jwk.n,\n                };\n                break;\n            case \"EC\":\n                jsonObject = {\n                    \"crv\": jwk.crv,\n                    \"kty\": jwk.kty,\n                    \"x\": jwk.x,\n                    \"y\": jwk.y,\n                };\n                break;\n            case \"OKP\":\n                jsonObject = {\n                    \"crv\": jwk.crv,\n                    \"kty\": jwk.kty,\n                    \"x\": jwk.x,\n                };\n                break;\n            case \"oct\":\n                jsonObject = {\n                    \"crv\": jwk.k,\n                    \"kty\": jwk.kty,\n                };\n                break;\n            default:\n                throw new Error(\"Unknown jwk type\");\n        }\n        const utf8encodedAndHashed = await CryptoUtils.hash(\"SHA-256\", JSON.stringify(jsonObject));\n        return CryptoUtils.encodeBase64Url(utf8encodedAndHashed);\n    }\n\n    public static async generateDPoPProof({\n        url,\n        accessToken,\n        httpMethod,\n        keyPair,\n        nonce,\n    }: GenerateDPoPProofOpts): Promise<string> {\n        let hashedToken: Uint8Array;\n        let encodedHash: string;\n\n        const payload: Record<string, string | number> = {\n            \"jti\": window.crypto.randomUUID(),\n            \"htm\": httpMethod ?? \"GET\",\n            \"htu\": url,\n            \"iat\": Math.floor(Date.now() / 1000),\n        };\n\n        if (accessToken) {\n            hashedToken = await CryptoUtils.hash(\"SHA-256\", accessToken);\n            encodedHash = CryptoUtils.encodeBase64Url(hashedToken);\n            payload.ath = encodedHash;\n        }\n\n        if (nonce) {\n            payload.nonce = nonce;\n        }\n\n        try {\n            const publicJwk = await crypto.subtle.exportKey(\"jwk\", keyPair.publicKey);\n            const header = {\n                \"alg\": \"ES256\",\n                \"typ\": \"dpop+jwt\",\n                \"jwk\": {\n                    \"crv\": publicJwk.crv,\n                    \"kty\": publicJwk.kty,\n                    \"x\": publicJwk.x,\n                    \"y\": publicJwk.y,\n                },\n            };\n            return await JwtUtils.generateSignedJwt(header, payload, keyPair.privateKey);\n        } catch (err) {\n            if (err instanceof TypeError) {\n                throw new Error(`Error exporting dpop public key: ${err.message}`);\n            } else {\n                throw err;\n            }\n        }\n    }\n\n    public static async generateDPoPJkt(keyPair: CryptoKeyPair) : Promise<string> {\n        try {\n            const publicJwk = await crypto.subtle.exportKey(\"jwk\", keyPair.publicKey);\n            return await CryptoUtils.customCalculateJwkThumbprint(publicJwk);\n        } catch (err) {\n            if (err instanceof TypeError) {\n                throw new Error(`Could not retrieve dpop keys from storage: ${err.message}`);\n            } else {\n                throw err;\n            }\n        }\n    }\n\n    public static async generateDPoPKeys() : Promise<CryptoKeyPair> {\n        return await window.crypto.subtle.generateKey(\n            {\n                name: \"ECDSA\",\n                namedCurve: \"P-256\",\n            },\n            false,\n            [\"sign\", \"verify\"],\n        );\n    }\n}\n", "// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger } from \"./Logger\";\n\n/**\n * @internal\n */\nexport type Callback<EventType extends unknown[]> = (...ev: EventType) => (Promise<void> | void);\n\n/**\n * @internal\n */\nexport class Event<EventType extends unknown[]> {\n    protected readonly _logger: Logger;\n\n    private readonly _callbacks: Array<Callback<EventType>> = [];\n\n    public constructor(protected readonly _name: string) {\n        this._logger = new Logger(`Event('${this._name}')`);\n    }\n\n    public addHandler(cb: Callback<EventType>): () => void {\n        this._callbacks.push(cb);\n        return () => this.removeHandler(cb);\n    }\n\n    public removeHandler(cb: Callback<EventType>): void {\n        const idx = this._callbacks.lastIndexOf(cb);\n        if (idx >= 0) {\n            this._callbacks.splice(idx, 1);\n        }\n    }\n\n    public async raise(...ev: EventType): Promise<void> {\n        this._logger.debug(\"raise:\", ...ev);\n        for (const cb of this._callbacks) {\n            await cb(...ev);\n        }\n    }\n}\n", "/**\n *\n * @public\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Window/open#window_features\n */\nexport interface PopupWindowFeatures {\n    left?: number;\n    top?: number;\n    width?: number;\n    height?: number;\n    menubar?: boolean | string;\n    toolbar?: boolean | string;\n    location?: boolean | string;\n    status?: boolean | string;\n    resizable?: boolean | string;\n    scrollbars?: boolean | string;\n    /** Close popup window after time in seconds, by default it is -1. To enable this feature, set value greater than 0. */\n    closePopupWindowAfterInSeconds?: number;\n\n    [k: string]: boolean | string | number | undefined;\n}\n\nexport class PopupUtils {\n    /**\n     * Populates a map of window features with a placement centered in front of\n     * the current window. If no explicit width is given, a default value is\n     * binned into [800, 720, 600, 480, 360] based on the current window's width.\n     */\n    static center({ ...features }: PopupWindowFeatures): PopupWindowFeatures {\n        if (features.width == null)\n            features.width = [800, 720, 600, 480].find(width => width <= window.outerWidth / 1.618) ?? 360;\n        features.left ??= Math.max(0, Math.round(window.screenX + (window.outerWidth - features.width) / 2));\n        if (features.height != null)\n            features.top ??= Math.max(0, Math.round(window.screenY + (window.outerHeight - features.height) / 2));\n        return features;\n    }\n\n    static serialize(features: PopupWindowFeatures): string {\n        return Object.entries(features)\n            .filter(([, value]) => value != null)\n            .map(([key, value]) => `${key}=${typeof value !== \"boolean\" ? value as string : value ? \"yes\" : \"no\"}`)\n            .join(\",\");\n    }\n}\n", "// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Event } from \"./Event\";\nimport { Logger } from \"./Logger\";\n\n/**\n * @internal\n */\nexport class Timer extends Event<[void]> {\n    protected readonly _logger = new Logger(`Timer('${this._name}')`);\n    private _timerHandle: ReturnType<typeof setInterval> | null = null;\n    private _expiration = 0;\n\n    // get the time\n    public static getEpochTime(): number {\n        return Math.floor(Date.now() / 1000);\n    }\n\n    public init(durationInSeconds: number): void {\n        const logger = this._logger.create(\"init\");\n        durationInSeconds = Math.max(Math.floor(durationInSeconds), 1);\n        const expiration = Timer.getEpochTime() + durationInSeconds;\n        if (this.expiration === expiration && this._timerHandle) {\n            // no need to reinitialize to same expiration, so bail out\n            logger.debug(\"skipping since already initialized for expiration at\", this.expiration);\n            return;\n        }\n\n        this.cancel();\n\n        logger.debug(\"using duration\", durationInSeconds);\n        this._expiration = expiration;\n\n        // we're using a fairly short timer and then checking the expiration in the\n        // callback to handle scenarios where the browser device sleeps, and then\n        // the timers end up getting delayed.\n        const timerDurationInSeconds = Math.min(durationInSeconds, 5);\n        this._timerHandle = setInterval(this._callback, timerDurationInSeconds * 1000);\n    }\n\n    public get expiration(): number {\n        return this._expiration;\n    }\n\n    public cancel(): void {\n        this._logger.create(\"cancel\");\n        if (this._timerHandle) {\n            clearInterval(this._timerHandle);\n            this._timerHandle = null;\n        }\n    }\n\n    protected _callback = (): void => {\n        const diff = this._expiration - Timer.getEpochTime();\n        this._logger.debug(\"timer completes in\", diff);\n\n        if (this._expiration <= Timer.getEpochTime()) {\n            this.cancel();\n            void super.raise();\n        }\n    };\n}\n", "// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\n/**\n * @internal\n */\nexport class UrlUtils {\n    public static readParams(url: string, responseMode: \"query\" | \"fragment\" = \"query\"): URLSearchParams {\n        if (!url) throw new TypeError(\"Invalid URL\");\n        // the base URL is irrelevant, it's just here to support relative url arguments\n        const parsedUrl = new URL(url, \"http://127.0.0.1\");\n        const params = parsedUrl[responseMode === \"fragment\" ? \"hash\" : \"search\"];\n        return new URLSearchParams(params.slice(1));\n    }\n}\n\n/**\n * @internal\n */\nexport const URL_STATE_DELIMITER = \";\";", "// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger } from \"../utils\";\n\n/**\n * Error class thrown in case of an authentication error.\n *\n * @public\n * @see https://openid.net/specs/openid-connect-core-1_0.html#AuthError\n */\nexport class ErrorResponse extends Error {\n    /** Marker to detect class: \"ErrorResponse\" */\n    public readonly name: string = \"ErrorResponse\";\n\n    /** An error code string that can be used to classify the types of errors that occur and to respond to errors. */\n    public readonly error: string | null;\n    /** additional information that can help a developer identify the cause of the error.*/\n    public readonly error_description: string | null;\n    /**\n     * URI identifying a human-readable web page with information about the error, used to provide the client\n       developer with additional information about the error.\n    */\n    public readonly error_uri: string | null;\n\n    /** custom state data set during the initial signin request */\n    public state?: unknown;\n\n    public readonly session_state: string | null;\n\n    public url_state?: string;\n\n    public constructor(\n        args: {\n            error?: string | null; error_description?: string | null; error_uri?: string | null;\n            userState?: unknown; session_state?: string | null; url_state?: string;\n        },\n        /** The x-www-form-urlencoded request body sent to the authority server */\n        public readonly form?: URLSearchParams,\n    ) {\n        super(args.error_description || args.error || \"\");\n\n        if (!args.error) {\n            Logger.error(\"ErrorResponse\", \"No error passed\");\n            throw new Error(\"No error passed\");\n        }\n\n        this.error = args.error;\n        this.error_description = args.error_description ?? null;\n        this.error_uri = args.error_uri ?? null;\n\n        this.state = args.userState;\n        this.session_state = args.session_state ?? null;\n        this.url_state = args.url_state;\n    }\n}\n", "// Copyright (C) 2021 AuthTS Contributors\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\n/**\n * Error class thrown in case of network timeouts (e.g IFrame time out).\n *\n * @public\n */\nexport class ErrorTimeout extends Error {\n    /** Marker to detect class: \"ErrorTimeout\" */\n    public readonly name: string = \"ErrorTimeout\";\n\n    public constructor(message?: string) {\n        super(message);\n    }\n}\n", "// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger, Timer } from \"./utils\";\nimport type { User } from \"./User\";\n\n/**\n * @public\n */\nexport type AccessTokenCallback = (...ev: unknown[]) => (Promise<void> | void);\n\n/**\n * @public\n */\nexport class AccessTokenEvents {\n    protected readonly _logger = new Logger(\"AccessTokenEvents\");\n\n    private readonly _expiringTimer = new Timer(\"Access token expiring\");\n    private readonly _expiredTimer = new Timer(\"Access token expired\");\n    private readonly _expiringNotificationTimeInSeconds: number;\n\n    public constructor(args: { expiringNotificationTimeInSeconds: number }) {\n        this._expiringNotificationTimeInSeconds = args.expiringNotificationTimeInSeconds;\n    }\n\n    public async load(container: User): Promise<void> {\n        const logger = this._logger.create(\"load\");\n        // only register events if there's an access token and it has an expiration\n        if (container.access_token && container.expires_in !== undefined) {\n            const duration = container.expires_in;\n            logger.debug(\"access token present, remaining duration:\", duration);\n\n            if (duration > 0) {\n                // only register expiring if we still have time\n                let expiring = duration - this._expiringNotificationTimeInSeconds;\n                if (expiring <= 0) {\n                    expiring = 1;\n                }\n\n                logger.debug(\"registering expiring timer, raising in\", expiring, \"seconds\");\n                this._expiringTimer.init(expiring);\n            }\n            else {\n                logger.debug(\"canceling existing expiring timer because we're past expiration.\");\n                this._expiringTimer.cancel();\n            }\n\n            // if it's negative, it will still fire\n            const expired = duration + 1;\n            logger.debug(\"registering expired timer, raising in\", expired, \"seconds\");\n            this._expiredTimer.init(expired);\n        }\n        else {\n            this._expiringTimer.cancel();\n            this._expiredTimer.cancel();\n        }\n    }\n\n    public async unload(): Promise<void> {\n        this._logger.debug(\"unload: canceling existing access token timers\");\n        this._expiringTimer.cancel();\n        this._expiredTimer.cancel();\n    }\n\n    /**\n     * Add callback: Raised prior to the access token expiring.\n     */\n    public addAccessTokenExpiring(cb: AccessTokenCallback): () => void {\n        return this._expiringTimer.addHandler(cb);\n    }\n    /**\n     * Remove callback: Raised prior to the access token expiring.\n     */\n    public removeAccessTokenExpiring(cb: AccessTokenCallback): void {\n        this._expiringTimer.removeHandler(cb);\n    }\n\n    /**\n     * Add callback: Raised after the access token has expired.\n     */\n    public addAccessTokenExpired(cb: AccessTokenCallback): () => void {\n        return this._expiredTimer.addHandler(cb);\n    }\n    /**\n     * Remove callback: Raised after the access token has expired.\n     */\n    public removeAccessTokenExpired(cb: AccessTokenCallback): void {\n        this._expiredTimer.removeHandler(cb);\n    }\n}\n", "// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger } from \"./utils\";\n\n/**\n * @internal\n */\nexport class CheckSessionIFrame {\n    private readonly _logger = new Logger(\"CheckSessionIFrame\");\n    private _frame_origin: string;\n    private _frame: HTMLIFrameElement;\n    private _timer: ReturnType<typeof setInterval> | null = null;\n    private _session_state: string | null = null;\n\n    public constructor(\n        private _callback: () => Promise<void>,\n        private _client_id: string,\n        url: string,\n        private _intervalInSeconds: number,\n        private _stopOnError: boolean,\n    ) {\n        const parsedUrl = new URL(url);\n        this._frame_origin = parsedUrl.origin;\n\n        this._frame = window.document.createElement(\"iframe\");\n\n        // shotgun approach\n        this._frame.style.visibility = \"hidden\";\n        this._frame.style.position = \"fixed\";\n        this._frame.style.left = \"-1000px\";\n        this._frame.style.top = \"0\";\n        this._frame.width = \"0\";\n        this._frame.height = \"0\";\n        this._frame.src = parsedUrl.href;\n    }\n\n    public load(): Promise<void> {\n        return new Promise<void>((resolve) => {\n            this._frame.onload = () => {\n                resolve();\n            };\n\n            window.document.body.appendChild(this._frame);\n            window.addEventListener(\"message\", this._message, false);\n        });\n    }\n\n    private _message = (e: MessageEvent<string>): void => {\n        if (e.origin === this._frame_origin &&\n            e.source === this._frame.contentWindow\n        ) {\n            if (e.data === \"error\") {\n                this._logger.error(\"error message from check session op iframe\");\n                if (this._stopOnError) {\n                    this.stop();\n                }\n            }\n            else if (e.data === \"changed\") {\n                this._logger.debug(\"changed message from check session op iframe\");\n                this.stop();\n                void this._callback();\n            }\n            else {\n                this._logger.debug(e.data + \" message from check session op iframe\");\n            }\n        }\n    };\n\n    public start(session_state: string): void {\n        if (this._session_state === session_state) {\n            return;\n        }\n\n        this._logger.create(\"start\");\n\n        this.stop();\n\n        this._session_state = session_state;\n\n        const send = () => {\n            if (!this._frame.contentWindow || !this._session_state) {\n                return;\n            }\n\n            this._frame.contentWindow.postMessage(this._client_id + \" \" + this._session_state, this._frame_origin);\n        };\n\n        // trigger now\n        send();\n\n        // and setup timer\n        this._timer = setInterval(send, this._intervalInSeconds * 1000);\n    }\n\n    public stop(): void {\n        this._logger.create(\"stop\");\n        this._session_state = null;\n\n        if (this._timer) {\n\n            clearInterval(this._timer);\n            this._timer = null;\n        }\n    }\n}\n", "// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger } from \"./utils\";\n\n/**\n * @public\n */\nexport class InMemoryWebStorage implements Storage {\n    private readonly _logger = new Logger(\"InMemoryWebStorage\");\n    private _data: Record<string, string> = {};\n\n    public clear(): void {\n        this._logger.create(\"clear\");\n        this._data = {};\n    }\n\n    public getItem(key: string): string {\n        this._logger.create(`getItem('${key}')`);\n        return this._data[key];\n    }\n\n    public setItem(key: string, value: string): void {\n        this._logger.create(`setItem('${key}')`);\n        this._data[key] = value;\n    }\n\n    public removeItem(key: string): void {\n        this._logger.create(`removeItem('${key}')`);\n        delete this._data[key];\n    }\n\n    public get length(): number {\n        return Object.getOwnPropertyNames(this._data).length;\n    }\n\n    public key(index: number): string {\n        return Object.getOwnPropertyNames(this._data)[index];\n    }\n}\n", "export class ErrorDPoPNonce extends Error {\n    /** Marker to detect class: \"ErrorDPoPNonce\" */\n    public readonly name: string = \"ErrorDPoPNonce\";\n    public readonly nonce: string;\n\n    public constructor(nonce: string, message?: string) {\n        super(message);\n        this.nonce = nonce;\n    }\n}\n", "// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { ErrorResponse, ErrorTimeout } from \"./errors\";\nimport type { ExtraHeader } from \"./OidcClientSettings\";\nimport { Logger } from \"./utils\";\nimport { ErrorDPoPNonce } from \"./errors/ErrorDPoPNonce\";\n\n/**\n * @internal\n */\nexport type JwtHandler = (text: string) => Promise<Record<string, unknown>>;\n\n/**\n * @internal\n */\nexport interface GetJsonOpts {\n    token?: string;\n    credentials?: RequestCredentials;\n    timeoutInSeconds?: number;\n}\n\n/**\n * @internal\n */\nexport interface PostFormOpts {\n    body: URLSearchParams;\n    basicAuth?: string;\n    timeoutInSeconds?: number;\n    initCredentials?: \"same-origin\" | \"include\" | \"omit\";\n    extraHeaders?: Record<string, ExtraHeader>;\n}\n\n/**\n * @internal\n */\nexport class JsonService {\n    private readonly _logger = new Logger(\"JsonService\");\n\n    private _contentTypes: string[] = [];\n\n    public constructor(\n        additionalContentTypes: string[] = [],\n        private _jwtHandler: JwtHandler | null = null,\n        private _extraHeaders: Record<string, ExtraHeader> = {},\n    ) {\n        this._contentTypes.push(...additionalContentTypes, \"application/json\");\n        if (_jwtHandler) {\n            this._contentTypes.push(\"application/jwt\");\n        }\n    }\n\n    protected async fetchWithTimeout(input: RequestInfo, init: RequestInit & { timeoutInSeconds?: number } = {}) {\n        const { timeoutInSeconds, ...initFetch } = init;\n        if (!timeoutInSeconds) {\n            return await fetch(input, initFetch);\n        }\n\n        const controller = new AbortController();\n        const timeoutId = setTimeout(() => controller.abort(), timeoutInSeconds * 1000);\n\n        try {\n            const response = await fetch(input, {\n                ...init,\n                signal: controller.signal,\n            });\n            return response;\n        }\n        catch (err) {\n            if (err instanceof DOMException && err.name === \"AbortError\") {\n                throw new ErrorTimeout(\"Network timed out\");\n            }\n            throw err;\n        }\n        finally {\n            clearTimeout(timeoutId);\n        }\n    }\n\n    public async getJson(url: string, {\n        token,\n        credentials,\n        timeoutInSeconds,\n    }: GetJsonOpts = {}): Promise<Record<string, unknown>> {\n        const logger = this._logger.create(\"getJson\");\n        const headers: HeadersInit = {\n            \"Accept\": this._contentTypes.join(\", \"),\n        };\n        if (token) {\n            logger.debug(\"token passed, setting Authorization header\");\n            headers[\"Authorization\"] = \"Bearer \" + token;\n        }\n\n        this._appendExtraHeaders(headers);\n\n        let response: Response;\n        try {\n            logger.debug(\"url:\", url);\n            response = await this.fetchWithTimeout(url, { method: \"GET\", headers, timeoutInSeconds, credentials });\n        }\n        catch (err) {\n            logger.error(\"Network Error\");\n            throw err;\n        }\n\n        logger.debug(\"HTTP response received, status\", response.status);\n        const contentType = response.headers.get(\"Content-Type\");\n        if (contentType && !this._contentTypes.find(item => contentType.startsWith(item))) {\n            logger.throw(new Error(`Invalid response Content-Type: ${(contentType ?? \"undefined\")}, from URL: ${url}`));\n        }\n        if (response.ok && this._jwtHandler && contentType?.startsWith(\"application/jwt\")) {\n            return await this._jwtHandler(await response.text());\n        }\n        let json: Record<string, unknown>;\n        try {\n            json = await response.json();\n        }\n        catch (err) {\n            logger.error(\"Error parsing JSON response\", err);\n            if (response.ok) throw err;\n            throw new Error(`${response.statusText} (${response.status})`);\n        }\n        if (!response.ok) {\n            logger.error(\"Error from server:\", json);\n            if (json.error) {\n                throw new ErrorResponse(json);\n            }\n            throw new Error(`${response.statusText} (${response.status}): ${JSON.stringify(json)}`);\n        }\n        return json;\n    }\n\n    public async postForm(url: string, {\n        body,\n        basicAuth,\n        timeoutInSeconds,\n        initCredentials,\n        extraHeaders,\n    }: PostFormOpts): Promise<Record<string, unknown>> {\n        const logger = this._logger.create(\"postForm\");\n        const headers: HeadersInit = {\n            \"Accept\": this._contentTypes.join(\", \"),\n            \"Content-Type\": \"application/x-www-form-urlencoded\",\n            ...extraHeaders,\n        };\n        if (basicAuth !== undefined) {\n            headers[\"Authorization\"] = \"Basic \" + basicAuth;\n        }\n\n        this._appendExtraHeaders(headers);\n\n        let response: Response;\n        try {\n            logger.debug(\"url:\", url);\n            response = await this.fetchWithTimeout(url, { method: \"POST\", headers, body, timeoutInSeconds, credentials: initCredentials });\n        }\n        catch (err) {\n            logger.error(\"Network error\");\n            throw err;\n        }\n\n        logger.debug(\"HTTP response received, status\", response.status);\n        const contentType = response.headers.get(\"Content-Type\");\n        if (contentType && !this._contentTypes.find(item => contentType.startsWith(item))) {\n            throw new Error(`Invalid response Content-Type: ${(contentType ?? \"undefined\")}, from URL: ${url}`);\n        }\n\n        const responseText = await response.text();\n\n        let json: Record<string, unknown> = {};\n        if (responseText) {\n            try {\n                json = JSON.parse(responseText);\n            }\n            catch (err) {\n                logger.error(\"Error parsing JSON response\", err);\n                if (response.ok) throw err;\n                throw new Error(`${response.statusText} (${response.status})`);\n            }\n        }\n\n        if (!response.ok) {\n            logger.error(\"Error from server:\", json);\n            if (response.headers.has(\"dpop-nonce\")) {\n                const nonce = response.headers.get(\"dpop-nonce\") as string;\n                throw new ErrorDPoPNonce(nonce, `${JSON.stringify(json)}`);\n            }\n            if (json.error) {\n                throw new ErrorResponse(json, body);\n            }\n            throw new Error(`${response.statusText} (${response.status}): ${JSON.stringify(json)}`);\n        }\n\n        return json;\n    }\n\n    private _appendExtraHeaders(\n        headers: Record<string, string>,\n    ): void {\n        const logger = this._logger.create(\"appendExtraHeaders\");\n        const customKeys = Object.keys(this._extraHeaders);\n        const protectedHeaders = [\n            \"accept\",\n            \"content-type\",\n        ];\n        const preventOverride = [\n            \"authorization\",\n        ];\n        if (customKeys.length === 0) {\n            return;\n        }\n        customKeys.forEach((headerName) => {\n            if (protectedHeaders.includes(headerName.toLocaleLowerCase())) {\n                logger.warn(\"Protected header could not be set\", headerName, protectedHeaders);\n                return;\n            }\n            if (preventOverride.includes(headerName.toLocaleLowerCase()) &&\n                Object.keys(headers).includes(headerName)) {\n                logger.warn(\"Header could not be overridden\", headerName, preventOverride);\n                return;\n            }\n            const content = (typeof this._extraHeaders[headerName] === \"function\") ?\n                (this._extraHeaders[headerName] as ()=>string)() :\n                this._extraHeaders[headerName];\n            if (content && content !== \"\") {\n                headers[headerName] = content;\n            }\n        });\n    }\n}\n", "// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger } from \"./utils\";\nimport { JsonService } from \"./JsonService\";\nimport type { OidcClientSettingsStore, SigningKey } from \"./OidcClientSettings\";\nimport type { OidcMetadata } from \"./OidcMetadata\";\n\n/**\n * @public\n * @see https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata\n */\nexport class MetadataService {\n    private readonly _logger = new Logger(\"MetadataService\");\n    private readonly _jsonService;\n\n    // cache\n    private _metadataUrl: string;\n    private _signingKeys: SigningKey[] | null = null;\n    private _metadata: Partial<OidcMetadata> | null = null;\n    private _fetchRequestCredentials: RequestCredentials | undefined;\n\n    public constructor(private readonly _settings: OidcClientSettingsStore) {\n        this._metadataUrl = this._settings.metadataUrl;\n        this._jsonService = new JsonService(\n            [\"application/jwk-set+json\"],\n            null,\n            this._settings.extraHeaders,\n        );\n        if (this._settings.signingKeys) {\n            this._logger.debug(\"using signingKeys from settings\");\n            this._signingKeys = this._settings.signingKeys;\n        }\n\n        if (this._settings.metadata) {\n            this._logger.debug(\"using metadata from settings\");\n            this._metadata = this._settings.metadata;\n        }\n\n        if (this._settings.fetchRequestCredentials) {\n            this._logger.debug(\"using fetchRequestCredentials from settings\");\n            this._fetchRequestCredentials = this._settings.fetchRequestCredentials;\n        }\n    }\n\n    public resetSigningKeys(): void {\n        this._signingKeys = null;\n    }\n\n    public async getMetadata(): Promise<Partial<OidcMetadata>> {\n        const logger = this._logger.create(\"getMetadata\");\n        if (this._metadata) {\n            logger.debug(\"using cached values\");\n            return this._metadata;\n        }\n\n        if (!this._metadataUrl) {\n            logger.throw(new Error(\"No authority or metadataUrl configured on settings\"));\n            // eslint-disable-next-line @typescript-eslint/only-throw-error\n            throw null; // https://github.com/microsoft/TypeScript/issues/46972\n        }\n\n        logger.debug(\"getting metadata from\", this._metadataUrl);\n        const metadata = await this._jsonService.getJson(this._metadataUrl, { credentials: this._fetchRequestCredentials, timeoutInSeconds: this._settings.requestTimeoutInSeconds });\n\n        logger.debug(\"merging remote JSON with seed metadata\");\n        this._metadata = Object.assign({}, metadata, this._settings.metadataSeed);\n        return this._metadata;\n    }\n\n    public getIssuer(): Promise<string> {\n        return this._getMetadataProperty(\"issuer\") as Promise<string>;\n    }\n\n    public getAuthorizationEndpoint(): Promise<string> {\n        return this._getMetadataProperty(\"authorization_endpoint\") as Promise<string>;\n    }\n\n    public getUserInfoEndpoint(): Promise<string> {\n        return this._getMetadataProperty(\"userinfo_endpoint\") as Promise<string>;\n    }\n\n    public getTokenEndpoint(optional: false): Promise<string>;\n    public getTokenEndpoint(optional?: true): Promise<string | undefined>;\n    public getTokenEndpoint(optional = true): Promise<string | undefined> {\n        return this._getMetadataProperty(\"token_endpoint\", optional) as Promise<string | undefined>;\n    }\n\n    public getCheckSessionIframe(): Promise<string | undefined> {\n        return this._getMetadataProperty(\"check_session_iframe\", true) as Promise<string | undefined>;\n    }\n\n    public getEndSessionEndpoint(): Promise<string | undefined> {\n        return this._getMetadataProperty(\"end_session_endpoint\", true) as Promise<string | undefined>;\n    }\n\n    public getRevocationEndpoint(optional: false): Promise<string>;\n    public getRevocationEndpoint(optional?: true): Promise<string | undefined>;\n    public getRevocationEndpoint(optional = true): Promise<string | undefined> {\n        return this._getMetadataProperty(\"revocation_endpoint\", optional) as Promise<string | undefined>;\n    }\n\n    public getKeysEndpoint(optional: false): Promise<string>;\n    public getKeysEndpoint(optional?: true): Promise<string | undefined>;\n    public getKeysEndpoint(optional = true): Promise<string | undefined> {\n        return this._getMetadataProperty(\"jwks_uri\", optional) as Promise<string | undefined>;\n    }\n\n    protected async _getMetadataProperty(name: keyof OidcMetadata, optional=false): Promise<string | boolean | string[] | undefined> {\n        const logger = this._logger.create(`_getMetadataProperty('${name}')`);\n\n        const metadata = await this.getMetadata();\n        logger.debug(\"resolved\");\n\n        if (metadata[name] === undefined) {\n            if (optional === true) {\n                logger.warn(\"Metadata does not contain optional property\");\n                return undefined;\n            }\n\n            logger.throw(new Error(\"Metadata does not contain property \" + name));\n        }\n\n        return metadata[name];\n    }\n\n    public async getSigningKeys(): Promise<SigningKey[] | null> {\n        const logger = this._logger.create(\"getSigningKeys\");\n        if (this._signingKeys) {\n            logger.debug(\"returning signingKeys from cache\");\n            return this._signingKeys;\n        }\n\n        const jwks_uri = await this.getKeysEndpoint(false);\n        logger.debug(\"got jwks_uri\", jwks_uri);\n\n        const keySet = await this._jsonService.getJson(jwks_uri, { timeoutInSeconds: this._settings.requestTimeoutInSeconds });\n        logger.debug(\"got key set\", keySet);\n\n        if (!Array.isArray(keySet.keys)) {\n            logger.throw(new Error(\"Missing keys on keyset\"));\n            // eslint-disable-next-line @typescript-eslint/only-throw-error\n            throw null; // https://github.com/microsoft/TypeScript/issues/46972\n        }\n\n        this._signingKeys = keySet.keys;\n        return this._signingKeys;\n    }\n}\n", "// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger } from \"./utils\";\nimport type { StateStore } from \"./StateStore\";\nimport type { AsyncStorage } from \"./AsyncStorage\";\n\n/**\n * @public\n */\nexport class WebStorageStateStore implements StateStore {\n    private readonly _logger = new Logger(\"WebStorageStateStore\");\n\n    private readonly _store: AsyncStorage | Storage;\n    private readonly _prefix: string;\n\n    public constructor({\n        prefix = \"oidc.\",\n        store = localStorage,\n    }: { prefix?: string; store?: AsyncStorage | Storage } = {}) {\n        this._store = store;\n        this._prefix = prefix;\n    }\n\n    public async set(key: string, value: string): Promise<void> {\n        this._logger.create(`set('${key}')`);\n\n        key = this._prefix + key;\n        await this._store.setItem(key, value);\n    }\n\n    public async get(key: string): Promise<string | null> {\n        this._logger.create(`get('${key}')`);\n\n        key = this._prefix + key;\n        const item = await this._store.getItem(key);\n        return item;\n    }\n\n    public async remove(key: string): Promise<string | null> {\n        this._logger.create(`remove('${key}')`);\n\n        key = this._prefix + key;\n        const item = await this._store.getItem(key);\n        await this._store.removeItem(key);\n        return item;\n    }\n\n    public async getAllKeys(): Promise<string[]> {\n        this._logger.create(\"getAllKeys\");\n        const len = await this._store.length;\n\n        const keys = [];\n        for (let index = 0; index < len; index++) {\n            const key = await this._store.key(index);\n            if (key && key.indexOf(this._prefix) === 0) {\n                keys.push(key.substr(this._prefix.length));\n            }\n        }\n        return keys;\n    }\n}\n", "// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { WebStorageStateStore } from \"./WebStorageStateStore\";\nimport type { OidcMetadata } from \"./OidcMetadata\";\nimport type { StateStore } from \"./StateStore\";\nimport { InMemoryWebStorage } from \"./InMemoryWebStorage\";\nimport type { DPoPStore } from \"./DPoPStore\";\n\nconst DefaultResponseType = \"code\";\nconst DefaultScope = \"openid\";\nconst DefaultClientAuthentication = \"client_secret_post\";\nconst DefaultStaleStateAgeInSeconds = 60 * 15;\n\n/**\n * @public\n */\nexport type SigningKey = Record<string, string | string[]>;\n\n/**\n * @public\n */\nexport type ExtraHeader = string | (() => string);\n\n/**\n * Optional DPoP settings\n * @public\n */\nexport interface DPoPSettings {\n    bind_authorization_code?: boolean;\n    store: DPoPStore;\n}\n\n/**\n * The settings used to configure the {@link OidcClient}.\n *\n * @public\n */\nexport interface OidcClientSettings {\n    /** The URL of the OIDC/OAuth2 provider */\n    authority: string;\n    metadataUrl?: string;\n    /** Provide metadata when authority server does not allow CORS on the metadata endpoint */\n    metadata?: Partial<OidcMetadata>;\n    /** Can be used to seed or add additional values to the results of the discovery request */\n    metadataSeed?: Partial<OidcMetadata>;\n    /** Provide signingKeys when authority server does not allow CORS on the jwks uri */\n    signingKeys?: SigningKey[];\n\n    /** Your client application's identifier as registered with the OIDC/OAuth2 */\n    client_id: string;\n    client_secret?: string;\n    /** The type of response desired from the OIDC/OAuth2 provider (default: \"code\") */\n    response_type?: string;\n    /** The scope being requested from the OIDC/OAuth2 provider (default: \"openid\") */\n    scope?: string;\n    /** The redirect URI of your client application to receive a response from the OIDC/OAuth2 provider */\n    redirect_uri: string;\n    /** The OIDC/OAuth2 post-logout redirect URI */\n    post_logout_redirect_uri?: string;\n\n    /**\n     * Client authentication method that is used to authenticate when using the token endpoint (default: \"client_secret_post\")\n     * - \"client_secret_basic\": using the HTTP Basic authentication scheme\n     * - \"client_secret_post\": including the client credentials in the request body\n     *\n     * See https://openid.net/specs/openid-connect-core-1_0.html#ClientAuthentication\n     */\n    client_authentication?: \"client_secret_basic\" | \"client_secret_post\";\n\n    /** optional protocol param */\n    prompt?: string;\n    /** optional protocol param */\n    display?: string;\n    /** optional protocol param */\n    max_age?: number;\n    /** optional protocol param */\n    ui_locales?: string;\n    /** optional protocol param */\n    acr_values?: string;\n    /** optional protocol param */\n    resource?: string | string[];\n\n    /**\n     * Optional protocol param\n     * The response mode used by the authority server is defined by the response_type unless explicitly specified:\n     * - Response mode for the OAuth 2.0 response type \"code\" is the \"query\" encoding\n     * - Response mode for the OAuth 2.0 response type \"token\" is the \"fragment\" encoding\n     *\n     * @see https://openid.net/specs/oauth-v2-multiple-response-types-1_0.html#ResponseModes\n     */\n    response_mode?: \"query\" | \"fragment\";\n\n    /**\n     * Should optional OIDC protocol claims be removed from profile or specify the ones to be removed (default: true)\n     * When true, the following claims are removed by default: [\"nbf\", \"jti\", \"auth_time\", \"nonce\", \"acr\", \"amr\", \"azp\", \"at_hash\"]\n     * When specifying claims, the following claims are not allowed: [\"sub\", \"iss\", \"aud\", \"exp\", \"iat\"]\n    */\n    filterProtocolClaims?: boolean | string[];\n    /** Flag to control if additional identity data is loaded from the user info endpoint in order to populate the user's profile (default: false) */\n    loadUserInfo?: boolean;\n    /** Number (in seconds) indicating the age of state entries in storage for authorize requests that are considered abandoned and thus can be cleaned up (default: 900) */\n    staleStateAgeInSeconds?: number;\n\n    /**\n     * Indicates how objects returned from the user info endpoint as claims (e.g. `address`) are merged into the claims from the\n     * id token as a single object.  (default: `{ array: \"replace\" }`)\n     * - array: \"replace\": natives (string, int, float) and arrays are replaced, objects are merged as distinct objects\n     * - array: \"merge\": natives (string, int, float) are replaced, arrays and objects are merged as distinct objects\n     */\n    mergeClaimsStrategy?: { array: \"replace\" | \"merge\" };\n\n    /**\n     * Storage object used to persist interaction state (default: window.localStorage, InMemoryWebStorage iff no window).\n     * E.g. `stateStore: new WebStorageStateStore({ store: window.localStorage })`\n     */\n    stateStore?: StateStore;\n\n    /**\n     * An object containing additional query string parameters to be including in the authorization request.\n     * E.g, when using Azure AD to obtain an access token an additional resource parameter is required. extraQueryParams: `{resource:\"some_identifier\"}`\n     */\n    extraQueryParams?: Record<string, string | number | boolean>;\n\n    extraTokenParams?: Record<string, unknown>;\n\n    /**\n     * An object containing additional header to be including in request.\n     */\n    extraHeaders?: Record<string, ExtraHeader>;\n\n    /**\n     * DPoP enabled or disabled\n     */\n    dpop?: DPoPSettings | undefined;\n\n    /**\n     * Will check the content type header of the response of the revocation endpoint to match these passed values (default: [])\n     */\n    revokeTokenAdditionalContentTypes?: string[];\n    /**\n     * Will disable PKCE validation, changing to true will not append to sign in request code_challenge and code_challenge_method. (default: false)\n     */\n    disablePKCE?: boolean;\n    /**\n     * Sets the credentials for fetch requests. (default: \"same-origin\")\n     * Use this if you need to send cookies to the OIDC/OAuth2 provider or if you are using a proxy that requires cookies\n     */\n    fetchRequestCredentials?: RequestCredentials;\n\n    /**\n     * Only scopes in this list will be passed in the token refresh request.\n     */\n    refreshTokenAllowedScope?: string | undefined;\n\n    /**\n     * Defines request timeouts globally across all requests made to the authorisation server\n     */\n    requestTimeoutInSeconds?: number | undefined;\n\n    /**\n     * https://datatracker.ietf.org/doc/html/rfc6749#section-3.3 describes behavior when omitting scopes from sign in requests\n     * If the IDP supports default scopes, this setting will ignore the scopes property passed to the config. (Default: false)\n     */\n    omitScopeWhenRequesting?: boolean;\n}\n\n/**\n * The settings with defaults applied of the {@link OidcClient}.\n *\n * @public\n * @see {@link OidcClientSettings}\n */\nexport class OidcClientSettingsStore {\n    // metadata\n    public readonly authority: string;\n    public readonly metadataUrl: string;\n    public readonly metadata: Partial<OidcMetadata> | undefined;\n    public readonly metadataSeed: Partial<OidcMetadata> | undefined;\n    public readonly signingKeys: SigningKey[] | undefined;\n\n    // client config\n    public readonly client_id: string;\n    public readonly client_secret: string | undefined;\n    public readonly response_type: string;\n    public readonly scope: string;\n    public readonly redirect_uri: string;\n    public readonly post_logout_redirect_uri: string | undefined;\n    public readonly client_authentication: \"client_secret_basic\" | \"client_secret_post\";\n\n    // optional protocol params\n    public readonly prompt: string | undefined;\n    public readonly display: string | undefined;\n    public readonly max_age: number | undefined;\n    public readonly ui_locales: string | undefined;\n    public readonly acr_values: string | undefined;\n    public readonly resource: string | string[] | undefined;\n    public readonly response_mode: \"query\" | \"fragment\" | undefined;\n\n    // behavior flags\n    public readonly filterProtocolClaims: boolean | string[];\n    public readonly loadUserInfo: boolean;\n    public readonly staleStateAgeInSeconds: number;\n    public readonly mergeClaimsStrategy: { array: \"replace\" | \"merge\" };\n    public readonly omitScopeWhenRequesting: boolean;\n\n    public readonly stateStore: StateStore;\n\n    // extra\n    public readonly extraQueryParams: Record<string, string | number | boolean>;\n    public readonly extraTokenParams: Record<string, unknown>;\n    public readonly dpop: DPoPSettings | undefined;\n    public readonly extraHeaders: Record<string, ExtraHeader>;\n\n    public readonly revokeTokenAdditionalContentTypes?: string[];\n    public readonly fetchRequestCredentials: RequestCredentials;\n    public readonly refreshTokenAllowedScope: string | undefined;\n    public readonly disablePKCE: boolean;\n    public readonly requestTimeoutInSeconds: number | undefined;\n\n    public constructor({\n        // metadata related\n        authority, metadataUrl, metadata, signingKeys, metadataSeed,\n        // client related\n        client_id, client_secret, response_type = DefaultResponseType, scope = DefaultScope,\n        redirect_uri, post_logout_redirect_uri,\n        client_authentication = DefaultClientAuthentication,\n        // optional protocol\n        prompt, display, max_age, ui_locales, acr_values, resource, response_mode,\n        // behavior flags\n        filterProtocolClaims = true,\n        loadUserInfo = false,\n        requestTimeoutInSeconds,\n        staleStateAgeInSeconds = DefaultStaleStateAgeInSeconds,\n        mergeClaimsStrategy = { array: \"replace\" },\n        disablePKCE = false,\n        // other behavior\n        stateStore,\n        revokeTokenAdditionalContentTypes,\n        fetchRequestCredentials,\n        refreshTokenAllowedScope,\n        // extra\n        extraQueryParams = {},\n        extraTokenParams = {},\n        extraHeaders = {},\n        dpop,\n        omitScopeWhenRequesting = false,\n    }: OidcClientSettings) {\n\n        this.authority = authority;\n\n        if (metadataUrl) {\n            this.metadataUrl = metadataUrl;\n        } else {\n            this.metadataUrl = authority;\n            if (authority) {\n                if (!this.metadataUrl.endsWith(\"/\")) {\n                    this.metadataUrl += \"/\";\n                }\n                this.metadataUrl += \".well-known/openid-configuration\";\n            }\n        }\n\n        this.metadata = metadata;\n        this.metadataSeed = metadataSeed;\n        this.signingKeys = signingKeys;\n\n        this.client_id = client_id;\n        this.client_secret = client_secret;\n        this.response_type = response_type;\n        this.scope = scope;\n        this.redirect_uri = redirect_uri;\n        this.post_logout_redirect_uri = post_logout_redirect_uri;\n        this.client_authentication = client_authentication;\n\n        this.prompt = prompt;\n        this.display = display;\n        this.max_age = max_age;\n        this.ui_locales = ui_locales;\n        this.acr_values = acr_values;\n        this.resource = resource;\n        this.response_mode = response_mode;\n\n        this.filterProtocolClaims = filterProtocolClaims ?? true;\n        this.loadUserInfo = !!loadUserInfo;\n        this.staleStateAgeInSeconds = staleStateAgeInSeconds;\n        this.mergeClaimsStrategy = mergeClaimsStrategy;\n        this.omitScopeWhenRequesting = omitScopeWhenRequesting;\n        this.disablePKCE = !!disablePKCE;\n        this.revokeTokenAdditionalContentTypes = revokeTokenAdditionalContentTypes;\n\n        this.fetchRequestCredentials = fetchRequestCredentials ? fetchRequestCredentials : \"same-origin\";\n        this.requestTimeoutInSeconds = requestTimeoutInSeconds;\n\n        if (stateStore) {\n            this.stateStore = stateStore;\n        }\n        else {\n            const store = typeof window !== \"undefined\" ? window.localStorage : new InMemoryWebStorage();\n            this.stateStore = new WebStorageStateStore({ store });\n        }\n\n        this.refreshTokenAllowedScope = refreshTokenAllowedScope;\n\n        this.extraQueryParams = extraQueryParams;\n        this.extraTokenParams = extraTokenParams;\n        this.extraHeaders = extraHeaders;\n\n        this.dpop = dpop;\n        if (this.dpop && !this.dpop?.store) {\n            throw new Error(\"A DPoPStore is required when dpop is enabled\");\n        }\n    }\n}\n", "// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger, JwtUtils } from \"./utils\";\nimport { JsonService } from \"./JsonService\";\nimport type { MetadataService } from \"./MetadataService\";\nimport type { JwtClaims } from \"./Claims\";\nimport type { OidcClientSettingsStore } from \"./OidcClientSettings\";\n\n/**\n * @internal\n */\nexport class UserInfoService {\n    protected readonly _logger = new Logger(\"UserInfoService\");\n    private readonly _jsonService: JsonService;\n\n    public constructor(private readonly _settings: OidcClientSettingsStore,\n        private readonly _metadataService: MetadataService,\n    ) {\n        this._jsonService = new JsonService(\n            undefined,\n            this._getClaimsFromJwt,\n            this._settings.extraHeaders,\n        );\n    }\n\n    public async getClaims(token: string): Promise<JwtClaims> {\n        const logger = this._logger.create(\"getClaims\");\n        if (!token) {\n            this._logger.throw(new Error(\"No token passed\"));\n        }\n\n        const url = await this._metadataService.getUserInfoEndpoint();\n        logger.debug(\"got userinfo url\", url);\n\n        const claims = await this._jsonService.getJson(url, {\n            token,\n            credentials: this._settings.fetchRequestCredentials,\n            timeoutInSeconds: this._settings.requestTimeoutInSeconds,\n        });\n        logger.debug(\"got claims\", claims);\n\n        return claims;\n    }\n\n    protected _getClaimsFromJwt = async (responseText: string): Promise<JwtClaims> => {\n        const logger = this._logger.create(\"_getClaimsFromJwt\");\n        try {\n            const payload = JwtUtils.decode(responseText);\n            logger.debug(\"JWT decoding successful\");\n\n            return payload;\n        } catch (err) {\n            logger.error(\"Error parsing JWT response\");\n            throw err;\n        }\n    };\n}\n", "// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { CryptoUtils, Logger } from \"./utils\";\nimport { JsonService } from \"./JsonService\";\nimport type { MetadataService } from \"./MetadataService\";\nimport type { ExtraHeader, OidcClientSettingsStore } from \"./OidcClientSettings\";\n\n/**\n * @internal\n */\nexport interface ExchangeCodeArgs {\n    client_id?: string;\n    client_secret?: string;\n    redirect_uri?: string;\n\n    grant_type?: string;\n    code: string;\n    code_verifier?: string;\n\n    extraHeaders?: Record<string, ExtraHeader>;\n}\n\n/**\n * @internal\n */\nexport interface ExchangeCredentialsArgs {\n    client_id?: string;\n    client_secret?: string;\n\n    grant_type?: string;\n    scope?: string;\n\n    username: string;\n    password: string;\n}\n\n/**\n * @internal\n */\nexport interface ExchangeRefreshTokenArgs {\n    client_id?: string;\n    client_secret?: string;\n    redirect_uri?: string;\n\n    grant_type?: string;\n    refresh_token: string;\n    scope?: string;\n    resource?: string | string[];\n\n    timeoutInSeconds?: number;\n\n    extraHeaders?: Record<string, ExtraHeader>;\n}\n\n/**\n * @internal\n */\nexport interface RevokeArgs {\n    token: string;\n    token_type_hint?: \"access_token\" | \"refresh_token\";\n}\n\n/**\n * @internal\n */\nexport class TokenClient {\n    private readonly _logger = new Logger(\"TokenClient\");\n    private readonly _jsonService;\n\n    public constructor(\n        private readonly _settings: OidcClientSettingsStore,\n        private readonly _metadataService: MetadataService,\n    ) {\n        this._jsonService = new JsonService(\n            this._settings.revokeTokenAdditionalContentTypes,\n            null,\n            this._settings.extraHeaders,\n        );\n    }\n\n    /**\n     * Exchange code.\n     *\n     * @see https://www.rfc-editor.org/rfc/rfc6749#section-4.1.3\n     */\n    public async exchangeCode({\n        grant_type = \"authorization_code\",\n        redirect_uri = this._settings.redirect_uri,\n        client_id = this._settings.client_id,\n        client_secret = this._settings.client_secret,\n        extraHeaders,\n        ...args\n    }: ExchangeCodeArgs): Promise<Record<string, unknown>> {\n        const logger = this._logger.create(\"exchangeCode\");\n        if (!client_id) {\n            logger.throw(new Error(\"A client_id is required\"));\n        }\n        if (!redirect_uri) {\n            logger.throw(new Error(\"A redirect_uri is required\"));\n        }\n        if (!args.code) {\n            logger.throw(new Error(\"A code is required\"));\n        }\n\n        const params = new URLSearchParams({ grant_type, redirect_uri });\n        for (const [key, value] of Object.entries(args)) {\n            if (value != null) {\n                params.set(key, value);\n            }\n        }\n        let basicAuth: string | undefined;\n        switch (this._settings.client_authentication) {\n            case \"client_secret_basic\":\n                if (client_secret === undefined || client_secret === null) {\n                    logger.throw(new Error(\"A client_secret is required\"));\n                    // eslint-disable-next-line @typescript-eslint/only-throw-error\n                    throw null; // https://github.com/microsoft/TypeScript/issues/46972\n                }\n                basicAuth = CryptoUtils.generateBasicAuth(client_id, client_secret);\n                break;\n            case \"client_secret_post\":\n                params.append(\"client_id\", client_id);\n                if (client_secret) {\n                    params.append(\"client_secret\", client_secret);\n                }\n                break;\n        }\n\n        const url = await this._metadataService.getTokenEndpoint(false);\n        logger.debug(\"got token endpoint\");\n\n        const response = await this._jsonService.postForm(url, {\n            body: params,\n            basicAuth,\n            timeoutInSeconds: this._settings.requestTimeoutInSeconds,\n            initCredentials: this._settings.fetchRequestCredentials,\n            extraHeaders,\n        });\n\n        logger.debug(\"got response\");\n\n        return response;\n    }\n\n    /**\n     * Exchange credentials.\n     *\n     * @see https://www.rfc-editor.org/rfc/rfc6749#section-4.3.2\n     */\n    public async exchangeCredentials({\n        grant_type = \"password\",\n        client_id = this._settings.client_id,\n        client_secret = this._settings.client_secret,\n        scope = this._settings.scope,\n        ...args\n    }: ExchangeCredentialsArgs): Promise<Record<string, unknown>> {\n        const logger = this._logger.create(\"exchangeCredentials\");\n\n        if (!client_id) {\n            logger.throw(new Error(\"A client_id is required\"));\n        }\n\n        const params = new URLSearchParams({ grant_type });\n        if (!this._settings.omitScopeWhenRequesting) {\n            params.set(\"scope\", scope);\n        }\n        for (const [key, value] of Object.entries(args)) {\n            if (value != null) {\n                params.set(key, value);\n            }\n        }\n\n        let basicAuth: string | undefined;\n        switch (this._settings.client_authentication) {\n            case \"client_secret_basic\":\n                if (client_secret === undefined || client_secret === null) {\n                    logger.throw(new Error(\"A client_secret is required\"));\n                    // eslint-disable-next-line @typescript-eslint/only-throw-error\n                    throw null; // https://github.com/microsoft/TypeScript/issues/46972\n                }\n                basicAuth = CryptoUtils.generateBasicAuth(client_id, client_secret);\n                break;\n            case \"client_secret_post\":\n                params.append(\"client_id\", client_id);\n                if (client_secret) {\n                    params.append(\"client_secret\", client_secret);\n                }\n                break;\n        }\n\n        const url = await this._metadataService.getTokenEndpoint(false);\n        logger.debug(\"got token endpoint\");\n\n        const response = await this._jsonService.postForm(url, { body: params, basicAuth, timeoutInSeconds: this._settings.requestTimeoutInSeconds, initCredentials: this._settings.fetchRequestCredentials });\n        logger.debug(\"got response\");\n\n        return response;\n    }\n\n    /**\n     * Exchange a refresh token.\n     *\n     * @see https://www.rfc-editor.org/rfc/rfc6749#section-6\n     */\n    public async exchangeRefreshToken({\n        grant_type = \"refresh_token\",\n        client_id = this._settings.client_id,\n        client_secret = this._settings.client_secret,\n        timeoutInSeconds,\n        extraHeaders,\n        ...args\n    }: ExchangeRefreshTokenArgs): Promise<Record<string, unknown>> {\n        const logger = this._logger.create(\"exchangeRefreshToken\");\n        if (!client_id) {\n            logger.throw(new Error(\"A client_id is required\"));\n        }\n        if (!args.refresh_token) {\n            logger.throw(new Error(\"A refresh_token is required\"));\n        }\n\n        const params = new URLSearchParams({ grant_type });\n        for (const [key, value] of Object.entries(args)) {\n            if (Array.isArray(value)) {\n                value.forEach(param => params.append(key, param));\n            }\n            else if (value != null) {\n                params.set(key, value);\n            }\n        }\n        let basicAuth: string | undefined;\n        switch (this._settings.client_authentication) {\n            case \"client_secret_basic\":\n                if (client_secret === undefined || client_secret === null) {\n                    logger.throw(new Error(\"A client_secret is required\"));\n                    // eslint-disable-next-line @typescript-eslint/only-throw-error\n                    throw null; // https://github.com/microsoft/TypeScript/issues/46972\n                }\n                basicAuth = CryptoUtils.generateBasicAuth(client_id, client_secret);\n                break;\n            case \"client_secret_post\":\n                params.append(\"client_id\", client_id);\n                if (client_secret) {\n                    params.append(\"client_secret\", client_secret);\n                }\n                break;\n        }\n\n        const url = await this._metadataService.getTokenEndpoint(false);\n        logger.debug(\"got token endpoint\");\n\n        const response = await this._jsonService.postForm(url, { body: params, basicAuth, timeoutInSeconds, initCredentials: this._settings.fetchRequestCredentials, extraHeaders });\n        logger.debug(\"got response\");\n\n        return response;\n    }\n\n    /**\n     * Revoke an access or refresh token.\n     *\n     * @see https://datatracker.ietf.org/doc/html/rfc7009#section-2.1\n     */\n    public async revoke(args: RevokeArgs): Promise<void> {\n        const logger = this._logger.create(\"revoke\");\n        if (!args.token) {\n            logger.throw(new Error(\"A token is required\"));\n        }\n\n        const url = await this._metadataService.getRevocationEndpoint(false);\n\n        logger.debug(`got revocation endpoint, revoking ${args.token_type_hint ?? \"default token type\"}`);\n\n        const params = new URLSearchParams();\n        for (const [key, value] of Object.entries(args)) {\n            if (value != null) {\n                params.set(key, value);\n            }\n        }\n        params.set(\"client_id\", this._settings.client_id);\n        if (this._settings.client_secret) {\n            params.set(\"client_secret\", this._settings.client_secret);\n        }\n\n        await this._jsonService.postForm(url, { body: params, timeoutInSeconds: this._settings.requestTimeoutInSeconds });\n        logger.debug(\"got response\");\n    }\n}\n", "// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger, JwtUtils } from \"./utils\";\nimport { ErrorResponse } from \"./errors\";\nimport type { MetadataService } from \"./MetadataService\";\nimport { UserInfoService } from \"./UserInfoService\";\nimport { TokenClient } from \"./TokenClient\";\nimport type { ExtraHeader, OidcClientSettingsStore } from \"./OidcClientSettings\";\nimport type { SigninState } from \"./SigninState\";\nimport type { SigninResponse } from \"./SigninResponse\";\nimport type { State } from \"./State\";\nimport type { SignoutResponse } from \"./SignoutResponse\";\nimport type { UserProfile } from \"./User\";\nimport type { RefreshState } from \"./RefreshState\";\nimport type { IdTokenClaims } from \"./Claims\";\nimport type { ClaimsService } from \"./ClaimsService\";\n\n/**\n * @internal\n */\nexport class ResponseValidator {\n    protected readonly _logger = new Logger(\"ResponseValidator\");\n    protected readonly _userInfoService: UserInfoService;\n    protected readonly _tokenClient: TokenClient;\n\n    public constructor(\n        protected readonly _settings: OidcClientSettingsStore,\n        protected readonly _metadataService: MetadataService,\n        protected readonly _claimsService: ClaimsService,\n    ) {\n        this._userInfoService = new UserInfoService(this._settings, this._metadataService);\n        this._tokenClient = new TokenClient(this._settings, this._metadataService);\n    }\n\n    public async validateSigninResponse(response: SigninResponse, state: SigninState, extraHeaders?: Record<string, ExtraHeader>): Promise<void> {\n        const logger = this._logger.create(\"validateSigninResponse\");\n\n        this._processSigninState(response, state);\n        logger.debug(\"state processed\");\n\n        await this._processCode(response, state, extraHeaders);\n        logger.debug(\"code processed\");\n\n        if (response.isOpenId) {\n            this._validateIdTokenAttributes(response);\n        }\n        logger.debug(\"tokens validated\");\n\n        await this._processClaims(response, state?.skipUserInfo, response.isOpenId);\n        logger.debug(\"claims processed\");\n    }\n\n    public async validateCredentialsResponse(response: SigninResponse, skipUserInfo: boolean): Promise<void> {\n        const logger = this._logger.create(\"validateCredentialsResponse\");\n        const shouldValidateSubClaim = response.isOpenId && !!response.id_token;\n\n        if (shouldValidateSubClaim) {\n            this._validateIdTokenAttributes(response);\n        }\n        logger.debug(\"tokens validated\");\n\n        await this._processClaims(response, skipUserInfo, shouldValidateSubClaim);\n        logger.debug(\"claims processed\");\n    }\n\n    public async validateRefreshResponse(response: SigninResponse, state: RefreshState): Promise<void> {\n        const logger = this._logger.create(\"validateRefreshResponse\");\n\n        response.userState = state.data;\n        // if there's no session_state on the response, copy over session_state from original request\n        response.session_state ??= state.session_state;\n        // if there's no scope on the response, then assume all scopes granted (per-spec) and copy over scopes from original request\n        response.scope ??= state.scope;\n\n        // OpenID Connect Core 1.0 says that id_token is optional in refresh response:\n        // https://openid.net/specs/openid-connect-core-1_0.html#RefreshTokenResponse\n        if (response.isOpenId && !!response.id_token) {\n            this._validateIdTokenAttributes(response, state.id_token);\n            logger.debug(\"ID Token validated\");\n        }\n\n        if (!response.id_token) {\n            // if there's no id_token on the response, copy over id_token from original request\n            response.id_token = state.id_token;\n            // and decoded part too\n            response.profile = state.profile;\n        }\n\n        const hasIdToken = response.isOpenId && !!response.id_token;\n        await this._processClaims(response, false, hasIdToken);\n        logger.debug(\"claims processed\");\n    }\n\n    public validateSignoutResponse(response: SignoutResponse, state: State): void {\n        const logger = this._logger.create(\"validateSignoutResponse\");\n        if (state.id !== response.state) {\n            logger.throw(new Error(\"State does not match\"));\n        }\n\n        // now that we know the state matches, take the stored data\n        // and set it into the response so callers can get their state\n        // this is important for both success & error outcomes\n        logger.debug(\"state validated\");\n        response.userState = state.data;\n\n        if (response.error) {\n            logger.warn(\"Response was error\", response.error);\n            throw new ErrorResponse(response);\n        }\n    }\n\n    protected _processSigninState(response: SigninResponse, state: SigninState): void {\n        const logger = this._logger.create(\"_processSigninState\");\n        if (state.id !== response.state) {\n            logger.throw(new Error(\"State does not match\"));\n        }\n\n        if (!state.client_id) {\n            logger.throw(new Error(\"No client_id on state\"));\n        }\n\n        if (!state.authority) {\n            logger.throw(new Error(\"No authority on state\"));\n        }\n\n        // ensure we're using the correct authority\n        if (this._settings.authority !== state.authority) {\n            logger.throw(new Error(\"authority mismatch on settings vs. signin state\"));\n        }\n        if (this._settings.client_id && this._settings.client_id !== state.client_id) {\n            logger.throw(new Error(\"client_id mismatch on settings vs. signin state\"));\n        }\n\n        // now that we know the state matches, take the stored data\n        // and set it into the response so callers can get their state\n        // this is important for both success & error outcomes\n        logger.debug(\"state validated\");\n        response.userState = state.data;\n        response.url_state = state.url_state;\n        // if there's no scope on the response, then assume all scopes granted (per-spec) and copy over scopes from original request\n        response.scope ??= state.scope;\n\n        if (response.error) {\n            logger.warn(\"Response was error\", response.error);\n            throw new ErrorResponse(response);\n        }\n\n        if (state.code_verifier && !response.code) {\n            logger.throw(new Error(\"Expected code in response\"));\n        }\n\n    }\n\n    protected async _processClaims(response: SigninResponse, skipUserInfo = false, validateSub = true): Promise<void> {\n        const logger = this._logger.create(\"_processClaims\");\n        response.profile = this._claimsService.filterProtocolClaims(response.profile);\n\n        if (skipUserInfo || !this._settings.loadUserInfo || !response.access_token) {\n            logger.debug(\"not loading user info\");\n            return;\n        }\n\n        logger.debug(\"loading user info\");\n        const claims = await this._userInfoService.getClaims(response.access_token);\n        logger.debug(\"user info claims received from user info endpoint\");\n\n        if (validateSub && claims.sub !== response.profile.sub) {\n            logger.throw(new Error(\"subject from UserInfo response does not match subject in ID Token\"));\n        }\n\n        response.profile = this._claimsService.mergeClaims(response.profile, this._claimsService.filterProtocolClaims(claims as IdTokenClaims));\n        logger.debug(\"user info claims received, updated profile:\", response.profile);\n    }\n\n    protected async _processCode(response: SigninResponse, state: SigninState, extraHeaders?: Record<string, ExtraHeader>): Promise<void> {\n        const logger = this._logger.create(\"_processCode\");\n        if (response.code) {\n            logger.debug(\"Validating code\");\n            const tokenResponse = await this._tokenClient.exchangeCode({\n                client_id: state.client_id,\n                client_secret: state.client_secret,\n                code: response.code,\n                redirect_uri: state.redirect_uri,\n                code_verifier: state.code_verifier,\n                extraHeaders: extraHeaders,\n                ...state.extraTokenParams,\n            });\n            Object.assign(response, tokenResponse);\n        } else {\n            logger.debug(\"No code to process\");\n        }\n    }\n\n    protected _validateIdTokenAttributes(response: SigninResponse, existingToken?: string): void {\n        const logger = this._logger.create(\"_validateIdTokenAttributes\");\n\n        logger.debug(\"decoding ID Token JWT\");\n        const incoming = JwtUtils.decode(response.id_token ?? \"\");\n\n        if (!incoming.sub) {\n            logger.throw(new Error(\"ID Token is missing a subject claim\"));\n        }\n\n        if (existingToken) {\n            const existing = JwtUtils.decode(existingToken);\n            if (incoming.sub !== existing.sub) {\n                logger.throw(new Error(\"sub in id_token does not match current sub\"));\n            }\n            if (incoming.auth_time && incoming.auth_time !== existing.auth_time) {\n                logger.throw(new Error(\"auth_time in id_token does not match original auth_time\"));\n            }\n            if (incoming.azp && incoming.azp !== existing.azp) {\n                logger.throw(new Error(\"azp in id_token does not match original azp\"));\n            }\n            if (!incoming.azp && existing.azp) {\n                logger.throw(new Error(\"azp not in id_token, but present in original id_token\"));\n            }\n        }\n\n        response.profile = incoming as UserProfile;\n    }\n}\n", "// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger, CryptoUtils, Timer } from \"./utils\";\nimport type { StateStore } from \"./StateStore\";\n\n/**\n * @public\n */\nexport class State {\n    public readonly id: string;\n    public readonly created: number;\n    public readonly request_type: string | undefined;\n    public readonly url_state: string | undefined;\n\n    /** custom \"state\", which can be used by a caller to have \"data\" round tripped */\n    public readonly data?: unknown;\n\n    public constructor(args: {\n        id?: string;\n        data?: unknown;\n        created?: number;\n        request_type?: string;\n        url_state?: string;\n    }) {\n        this.id = args.id || CryptoUtils.generateUUIDv4();\n        this.data = args.data;\n\n        if (args.created && args.created > 0) {\n            this.created = args.created;\n        }\n        else {\n            this.created = Timer.getEpochTime();\n        }\n        this.request_type = args.request_type;\n        this.url_state = args.url_state;\n    }\n\n    public toStorageString(): string {\n        new Logger(\"State\").create(\"toStorageString\");\n        return JSON.stringify({\n            id: this.id,\n            data: this.data,\n            created: this.created,\n            request_type: this.request_type,\n            url_state: this.url_state,\n        });\n    }\n\n    public static fromStorageString(storageString: string): Promise<State> {\n        Logger.createStatic(\"State\", \"fromStorageString\");\n        return Promise.resolve(new State(JSON.parse(storageString)));\n    }\n\n    public static async clearStaleState(storage: StateStore, age: number): Promise<void> {\n        const logger = Logger.createStatic(\"State\", \"clearStaleState\");\n        const cutoff = Timer.getEpochTime() - age;\n\n        const keys = await storage.getAllKeys();\n        logger.debug(\"got keys\", keys);\n\n        for (let i = 0; i < keys.length; i++) {\n            const key = keys[i];\n            const item = await storage.get(key);\n            let remove = false;\n\n            if (item) {\n                try {\n                    const state = await State.fromStorageString(item);\n\n                    logger.debug(\"got item from key:\", key, state.created);\n                    if (state.created <= cutoff) {\n                        remove = true;\n                    }\n                }\n                catch (err) {\n                    logger.error(\"Error parsing state for key:\", key, err);\n                    remove = true;\n                }\n            }\n            else {\n                logger.debug(\"no item in storage for key:\", key);\n                remove = true;\n            }\n\n            if (remove) {\n                logger.debug(\"removed item for key:\", key);\n                void storage.remove(key);\n            }\n        }\n    }\n}\n", "// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger, CryptoUtils } from \"./utils\";\nimport { State } from \"./State\";\n\n/** @public */\nexport interface SigninStateArgs {\n    id?: string;\n    data?: unknown;\n    created?: number;\n    request_type?: string;\n\n    code_verifier?: string;\n    code_challenge?: string;\n    authority: string;\n    client_id: string;\n    redirect_uri: string;\n    scope: string;\n    client_secret?: string;\n    extraTokenParams?: Record<string, unknown>;\n    response_mode?: \"query\" | \"fragment\";\n    skipUserInfo?: boolean;\n    url_state?: string;\n}\n\n/** @public */\nexport type SigninStateCreateArgs = Omit<SigninStateArgs, \"code_verifier\"> & {\n    code_verifier?: string | boolean;\n};\n\n/**\n * @public\n */\nexport class SigninState extends State {\n    // isCode\n    /** The same code_verifier that was used to obtain the authorization_code via PKCE. */\n    public readonly code_verifier: string | undefined;\n    /** Used to secure authorization code grants via Proof Key for Code Exchange (PKCE). */\n    public readonly code_challenge: string | undefined;\n\n    // to ensure state still matches settings\n    /** @see {@link OidcClientSettings.authority} */\n    public readonly authority: string;\n    /** @see {@link OidcClientSettings.client_id} */\n    public readonly client_id: string;\n    /** @see {@link OidcClientSettings.redirect_uri} */\n    public readonly redirect_uri: string;\n    /** @see {@link OidcClientSettings.scope} */\n    public readonly scope: string;\n    /** @see {@link OidcClientSettings.client_secret} */\n    public readonly client_secret: string | undefined;\n    /** @see {@link OidcClientSettings.extraTokenParams} */\n    public readonly extraTokenParams: Record<string, unknown> | undefined;\n    /** @see {@link OidcClientSettings.response_mode} */\n    public readonly response_mode: \"query\" | \"fragment\" | undefined;\n\n    public readonly skipUserInfo: boolean | undefined;\n\n    private constructor(args: SigninStateArgs) {\n        super(args);\n\n        this.code_verifier = args.code_verifier;\n        this.code_challenge = args.code_challenge;\n        this.authority = args.authority;\n        this.client_id = args.client_id;\n        this.redirect_uri = args.redirect_uri;\n        this.scope = args.scope;\n        this.client_secret = args.client_secret;\n        this.extraTokenParams = args.extraTokenParams;\n\n        this.response_mode = args.response_mode;\n        this.skipUserInfo = args.skipUserInfo;\n    }\n\n    public static async create(args: SigninStateCreateArgs): Promise<SigninState> {\n        const code_verifier = args.code_verifier === true ? CryptoUtils.generateCodeVerifier() : (args.code_verifier || undefined);\n        const code_challenge = code_verifier ? (await CryptoUtils.generateCodeChallenge(code_verifier)) : undefined;\n\n        return new SigninState({\n            ...args,\n            code_verifier,\n            code_challenge,\n        });\n    }\n\n    public toStorageString(): string {\n        new Logger(\"SigninState\").create(\"toStorageString\");\n        return JSON.stringify({\n            id: this.id,\n            data: this.data,\n            created: this.created,\n            request_type: this.request_type,\n            url_state: this.url_state,\n\n            code_verifier: this.code_verifier,\n            authority: this.authority,\n            client_id: this.client_id,\n            redirect_uri: this.redirect_uri,\n            scope: this.scope,\n            client_secret: this.client_secret,\n            extraTokenParams : this.extraTokenParams,\n            response_mode: this.response_mode,\n            skipUserInfo: this.skipUserInfo,\n        });\n    }\n\n    public static fromStorageString(storageString: string): Promise<SigninState> {\n        Logger.createStatic(\"SigninState\", \"fromStorageString\");\n        const data = JSON.parse(storageString);\n        return SigninState.create(data);\n    }\n}\n", "// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger, URL_STATE_DELIMITER } from \"./utils\";\nimport { SigninState } from \"./SigninState\";\n\n/**\n * @public\n * @see https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest\n */\nexport interface SigninRequestCreateArgs {\n    // mandatory\n    url: string;\n    authority: string;\n    client_id: string;\n    redirect_uri: string;\n    response_type: string;\n    scope: string;\n\n    // optional\n    response_mode?: \"query\" | \"fragment\";\n    nonce?: string;\n    display?: string;\n    dpopJkt?: string;\n    prompt?: string;\n    max_age?: number;\n    ui_locales?: string;\n    id_token_hint?: string;\n    login_hint?: string;\n    acr_values?: string;\n\n    // other\n    resource?: string | string[];\n    request?: string;\n    request_uri?: string;\n    request_type?: string;\n    extraQueryParams?: Record<string, string | number | boolean>;\n\n    // special\n    extraTokenParams?: Record<string, unknown>;\n    client_secret?: string;\n    skipUserInfo?: boolean;\n    disablePKCE?: boolean;\n    /** custom \"state\", which can be used by a caller to have \"data\" round tripped */\n    state_data?: unknown;\n    url_state?: string;\n    omitScopeWhenRequesting?: boolean;\n}\n\n/**\n * @public\n */\nexport class SigninRequest {\n    private static readonly _logger = new Logger(\"SigninRequest\");\n\n    public readonly url: string;\n    public readonly state: SigninState;\n\n    private constructor(args: {\n        url: string;\n        state: SigninState;\n    }) {\n        this.url = args.url;\n        this.state = args.state;\n    }\n\n    public static async create({\n        // mandatory\n        url, authority, client_id, redirect_uri, response_type, scope,\n        // optional\n        state_data, response_mode, request_type, client_secret, nonce, url_state,\n        resource,\n        skipUserInfo,\n        extraQueryParams,\n        extraTokenParams,\n        disablePKCE,\n        dpopJkt,\n        omitScopeWhenRequesting,\n        ...optionalParams\n    }: SigninRequestCreateArgs): Promise<SigninRequest> {\n        if (!url) {\n            this._logger.error(\"create: No url passed\");\n            throw new Error(\"url\");\n        }\n        if (!client_id) {\n            this._logger.error(\"create: No client_id passed\");\n            throw new Error(\"client_id\");\n        }\n        if (!redirect_uri) {\n            this._logger.error(\"create: No redirect_uri passed\");\n            throw new Error(\"redirect_uri\");\n        }\n        if (!response_type) {\n            this._logger.error(\"create: No response_type passed\");\n            throw new Error(\"response_type\");\n        }\n        if (!scope) {\n            this._logger.error(\"create: No scope passed\");\n            throw new Error(\"scope\");\n        }\n        if (!authority) {\n            this._logger.error(\"create: No authority passed\");\n            throw new Error(\"authority\");\n        }\n\n        const state = await SigninState.create({\n            data: state_data,\n            request_type,\n            url_state,\n            code_verifier: !disablePKCE,\n            client_id, authority, redirect_uri,\n            response_mode,\n            client_secret, scope, extraTokenParams,\n            skipUserInfo,\n        });\n\n        const parsedUrl = new URL(url);\n        parsedUrl.searchParams.append(\"client_id\", client_id);\n        parsedUrl.searchParams.append(\"redirect_uri\", redirect_uri);\n        parsedUrl.searchParams.append(\"response_type\", response_type);\n        if (!omitScopeWhenRequesting) {\n            parsedUrl.searchParams.append(\"scope\", scope);\n        }\n        if (nonce) {\n            parsedUrl.searchParams.append(\"nonce\", nonce);\n        }\n\n        if (dpopJkt) {\n            parsedUrl.searchParams.append(\"dpop_jkt\", dpopJkt);\n        }\n\n        let stateParam = state.id;\n        if (url_state) {\n            stateParam = `${stateParam}${URL_STATE_DELIMITER}${url_state}`;\n        }\n        parsedUrl.searchParams.append(\"state\", stateParam);\n        if (state.code_challenge) {\n            parsedUrl.searchParams.append(\"code_challenge\", state.code_challenge);\n            parsedUrl.searchParams.append(\"code_challenge_method\", \"S256\");\n        }\n\n        if (resource) {\n            // https://datatracker.ietf.org/doc/html/rfc8707\n            const resources = Array.isArray(resource) ? resource : [resource];\n            resources\n                .forEach(r => parsedUrl.searchParams.append(\"resource\", r));\n        }\n\n        for (const [key, value] of Object.entries({ response_mode, ...optionalParams, ...extraQueryParams })) {\n            if (value != null) {\n                parsedUrl.searchParams.append(key, value.toString());\n            }\n        }\n\n        return new SigninRequest({\n            url: parsedUrl.href,\n            state,\n        });\n    }\n}\n", "// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Timer, URL_STATE_DELIMITER } from \"./utils\";\nimport type { UserProfile } from \"./User\";\n\nconst OidcScope = \"openid\";\n\n/**\n * @public\n * @see https://openid.net/specs/openid-connect-core-1_0.html#AuthResponse\n * @see https://openid.net/specs/openid-connect-core-1_0.html#AuthError\n */\nexport class SigninResponse {\n    // props present in the initial callback response regardless of success\n    public readonly state: string | null;\n    /** @see {@link User.session_state} */\n    public session_state: string | null;\n\n    // error props\n    /** @see {@link ErrorResponse.error} */\n    public readonly error: string | null;\n    /** @see {@link ErrorResponse.error_description} */\n    public readonly error_description: string | null;\n    /** @see {@link ErrorResponse.error_uri} */\n    public readonly error_uri: string | null;\n\n    // success props\n    public readonly code: string | null;\n\n    // props set after validation\n    /** @see {@link User.id_token} */\n    public id_token?: string;\n    /** @see {@link User.access_token} */\n    public access_token = \"\";\n    /** @see {@link User.token_type} */\n    public token_type = \"\";\n    /** @see {@link User.refresh_token} */\n    public refresh_token?: string;\n    /** @see {@link User.scope} */\n    public scope?: string;\n    /** @see {@link User.expires_at} */\n    public expires_at?: number;\n\n    /** custom state data set during the initial signin request */\n    public userState: unknown;\n    public url_state?: string;\n\n    /** @see {@link User.profile} */\n    public profile: UserProfile = {} as UserProfile;\n\n    public constructor(params: URLSearchParams) {\n        this.state = params.get(\"state\");\n        this.session_state = params.get(\"session_state\");\n        if (this.state) {\n            const splitState = decodeURIComponent(this.state).split(URL_STATE_DELIMITER);\n            this.state = splitState[0];\n            if (splitState.length > 1) {\n                this.url_state = splitState.slice(1).join(URL_STATE_DELIMITER);\n            }\n        }\n\n        this.error = params.get(\"error\");\n        this.error_description = params.get(\"error_description\");\n        this.error_uri = params.get(\"error_uri\");\n\n        this.code = params.get(\"code\");\n    }\n\n    public get expires_in(): number | undefined {\n        if (this.expires_at === undefined) {\n            return undefined;\n        }\n        return this.expires_at - Timer.getEpochTime();\n    }\n    public set expires_in(value: number | undefined) {\n        // spec expects a number, but normalize here just in case\n        if (typeof value === \"string\") value = Number(value);\n        if (value !== undefined && value >= 0) {\n            this.expires_at = Math.floor(value) + Timer.getEpochTime();\n        }\n    }\n\n    public get isOpenId(): boolean {\n        return this.scope?.split(\" \").includes(OidcScope) || !!this.id_token;\n    }\n}\n", "// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger, URL_STATE_DELIMITER } from \"./utils\";\nimport { State } from \"./State\";\n\n/**\n * @public\n * @see https://openid.net/specs/openid-connect-rpinitiated-1_0.html#RPLogout\n */\nexport interface SignoutRequestArgs {\n    // mandatory\n    url: string;\n\n    // optional\n    id_token_hint?: string;\n    client_id?: string;\n    post_logout_redirect_uri?: string;\n    extraQueryParams?: Record<string, string | number | boolean>;\n\n    // special\n    request_type?: string;\n    /** custom \"state\", which can be used by a caller to have \"data\" round tripped */\n    state_data?: unknown;\n    url_state?: string;\n}\n\n/**\n * @public\n */\nexport class SignoutRequest {\n    private readonly _logger = new Logger(\"SignoutRequest\");\n\n    public readonly url: string;\n    public readonly state?: State;\n\n    public constructor({\n        url,\n        state_data, id_token_hint, post_logout_redirect_uri, extraQueryParams, request_type, client_id, url_state,\n    }: SignoutRequestArgs) {\n        if (!url) {\n            this._logger.error(\"ctor: No url passed\");\n            throw new Error(\"url\");\n        }\n\n        const parsedUrl = new URL(url);\n        if (id_token_hint) {\n            parsedUrl.searchParams.append(\"id_token_hint\", id_token_hint);\n        }\n        if (client_id) {\n            parsedUrl.searchParams.append(\"client_id\", client_id);\n        }\n\n        if (post_logout_redirect_uri) {\n            parsedUrl.searchParams.append(\"post_logout_redirect_uri\", post_logout_redirect_uri);\n\n            // Add state if either data needs to be stored, or url_state set for an intermediate proxy\n            if (state_data || url_state) {\n                this.state = new State({ data: state_data, request_type, url_state });\n\n                let stateParam = this.state.id;\n                if (url_state) {\n                    stateParam = `${stateParam}${URL_STATE_DELIMITER}${url_state}`;\n                }\n                parsedUrl.searchParams.append(\"state\", stateParam);\n            }\n        }\n\n        for (const [key, value] of Object.entries({ ...extraQueryParams })) {\n            if (value != null) {\n                parsedUrl.searchParams.append(key, value.toString());\n            }\n        }\n\n        this.url = parsedUrl.href;\n    }\n}\n", "// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { URL_STATE_DELIMITER } from \"./utils\";\n\n/**\n * @public\n * @see https://openid.net/specs/openid-connect-core-1_0.html#AuthError\n */\nexport class SignoutResponse {\n    public readonly state: string | null;\n\n    // error props\n    /** @see {@link ErrorResponse.error} */\n    public error: string | null;\n    /** @see {@link ErrorResponse.error_description} */\n    public error_description: string | null;\n    /** @see {@link ErrorResponse.error_uri} */\n    public error_uri: string | null;\n\n    /** custom state data set during the initial signin request */\n    public userState: unknown;\n    public url_state?: string;\n\n    public constructor(params: URLSearchParams) {\n        this.state = params.get(\"state\");\n        if (this.state) {\n            const splitState = decodeURIComponent(this.state).split(URL_STATE_DELIMITER);\n            this.state = splitState[0];\n            if (splitState.length > 1) {\n                this.url_state = splitState.slice(1).join(URL_STATE_DELIMITER);\n            }\n        }\n\n        this.error = params.get(\"error\");\n        this.error_description = params.get(\"error_description\");\n        this.error_uri = params.get(\"error_uri\");\n    }\n}\n", "// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport type { JwtClaims } from \"./Claims\";\nimport type { OidcClientSettingsStore } from \"./OidcClientSettings\";\nimport type { UserProfile } from \"./User\";\nimport { Logger } from \"./utils\";\n\n/**\n * Protocol claims that could be removed by default from profile.\n * Derived from the following sets of claims:\n * - {@link https://datatracker.ietf.org/doc/html/rfc7519.html#section-4.1}\n * - {@link https://openid.net/specs/openid-connect-core-1_0.html#IDToken}\n * - {@link https://openid.net/specs/openid-connect-core-1_0.html#CodeIDToken}\n *\n * @internal\n */\nconst DefaultProtocolClaims = [\n    \"nbf\",\n    \"jti\",\n    \"auth_time\",\n    \"nonce\",\n    \"acr\",\n    \"amr\",\n    \"azp\",\n    \"at_hash\", // https://openid.net/specs/openid-connect-core-1_0.html#CodeIDToken\n] as const;\n\n/**\n * Protocol claims that should never be removed from profile.\n * \"sub\" is needed internally and others should remain required as per the OIDC specs.\n *\n * @internal\n */\nconst InternalRequiredProtocolClaims = [\"sub\", \"iss\", \"aud\", \"exp\", \"iat\"];\n\n/**\n * @internal\n */\nexport class ClaimsService {\n    protected readonly _logger = new Logger(\"ClaimsService\");\n    public constructor(\n        protected readonly _settings: OidcClientSettingsStore,\n    ) {}\n\n    public filterProtocolClaims(claims: UserProfile): UserProfile {\n        const result = { ...claims };\n\n        if (this._settings.filterProtocolClaims) {\n            let protocolClaims;\n            if (Array.isArray(this._settings.filterProtocolClaims)) {\n                protocolClaims = this._settings.filterProtocolClaims;\n            } else {\n                protocolClaims = DefaultProtocolClaims;\n            }\n\n            for (const claim of protocolClaims) {\n                if (!InternalRequiredProtocolClaims.includes(claim)) {\n                    delete result[claim];\n                }\n            }\n        }\n\n        return result;\n    }\n\n    public mergeClaims(claims1: JwtClaims, claims2: JwtClaims): UserProfile;\n    public mergeClaims(claims1: UserProfile, claims2: JwtClaims): UserProfile {\n        const result = { ...claims1 };\n        for (const [claim, values] of Object.entries(claims2)) {\n            if (result[claim] !== values) {\n                if (Array.isArray(result[claim]) || Array.isArray(values)) {\n                    if (this._settings.mergeClaimsStrategy.array == \"replace\") {\n                        result[claim] = values;\n                    } else {\n                        const mergedValues = Array.isArray(result[claim]) ? result[claim] as unknown[] : [result[claim]];\n                        for (const value of Array.isArray(values) ? values : [values]) {\n                            if (!mergedValues.includes(value)) {\n                                mergedValues.push(value);\n                            }\n                        }\n                        result[claim] = mergedValues;\n                    }\n                } else if (typeof result[claim] === \"object\" && typeof values === \"object\") {\n                    result[claim] = this.mergeClaims(result[claim] as JwtClaims, values as JwtClaims);\n                } else {\n                    result[claim] = values;\n                }\n            }\n        }\n\n        return result;\n    }\n}\n", "/**\n * @public\n */\nexport interface DPoPStore {\n    set(key: string, value: DPoPState): Promise<void>;\n    get(key: string): Promise<DPoPState>;\n    remove(key: string): Promise<DPoPState>;\n    getAllKeys(): Promise<string[]>;\n}\n\n/**\n * @public\n */\nexport class DPoPState {\n    public constructor(\n        public readonly keys: CryptoKeyPair,\n        public nonce?: string,\n    ) { }\n}\n", "// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { CryptoUtils, Logger, UrlUtils } from \"./utils\";\nimport { ErrorResponse } from \"./errors\";\nimport { type ExtraHeader, type OidcClientSettings, OidcClientSettingsStore } from \"./OidcClientSettings\";\nimport { ResponseValidator } from \"./ResponseValidator\";\nimport { MetadataService } from \"./MetadataService\";\nimport type { RefreshState } from \"./RefreshState\";\nimport { SigninRequest, type SigninRequestCreateArgs } from \"./SigninRequest\";\nimport { SigninResponse } from \"./SigninResponse\";\nimport { SignoutRequest, type SignoutRequestArgs } from \"./SignoutRequest\";\nimport { SignoutResponse } from \"./SignoutResponse\";\nimport { SigninState } from \"./SigninState\";\nimport { State } from \"./State\";\nimport { TokenClient } from \"./TokenClient\";\nimport { ClaimsService } from \"./ClaimsService\";\nimport { DPoPState, type DPoPStore } from \"./DPoPStore\";\nimport { ErrorDPoPNonce } from \"./errors/ErrorDPoPNonce\";\n\n/**\n * @public\n */\nexport interface CreateSigninRequestArgs\n    extends Omit<SigninRequestCreateArgs, \"url\" | \"authority\" | \"client_id\" | \"redirect_uri\" | \"response_type\" | \"scope\" | \"state_data\"> {\n    redirect_uri?: string;\n    response_type?: string;\n    scope?: string;\n    dpopJkt?: string;\n\n    /** custom \"state\", which can be used by a caller to have \"data\" round tripped */\n    state?: unknown;\n}\n\n/**\n * @public\n */\nexport interface UseRefreshTokenArgs {\n    redirect_uri?: string;\n    resource?: string | string[];\n    extraTokenParams?: Record<string, unknown>;\n    timeoutInSeconds?: number;\n\n    state: RefreshState;\n\n    extraHeaders?: Record<string, ExtraHeader>;\n}\n\n/**\n * @public\n */\nexport type CreateSignoutRequestArgs = Omit<SignoutRequestArgs, \"url\" | \"state_data\"> & {\n    /** custom \"state\", which can be used by a caller to have \"data\" round tripped */\n    state?: unknown;\n};\n\n/**\n * @public\n */\nexport type ProcessResourceOwnerPasswordCredentialsArgs = {\n    username: string;\n    password: string;\n    skipUserInfo?: boolean;\n    extraTokenParams?: Record<string, unknown>;\n};\n\n/**\n * Provides the raw OIDC/OAuth2 protocol support for the authorization endpoint and the end session endpoint in the\n * authorization server. It provides a bare-bones protocol implementation and is used by the UserManager class.\n * Only use this class if you simply want protocol support without the additional management features of the\n * UserManager class.\n *\n * @public\n */\nexport class OidcClient {\n    public readonly settings: OidcClientSettingsStore;\n    protected readonly _logger = new Logger(\"OidcClient\");\n\n    public readonly metadataService: MetadataService;\n    protected readonly _claimsService: ClaimsService;\n    protected readonly _validator: ResponseValidator;\n    protected readonly _tokenClient: TokenClient;\n\n    public constructor(settings: OidcClientSettings);\n    public constructor(settings: OidcClientSettingsStore, metadataService: MetadataService);\n    public constructor(settings: OidcClientSettings | OidcClientSettingsStore, metadataService?: MetadataService) {\n        this.settings = settings instanceof OidcClientSettingsStore ? settings : new OidcClientSettingsStore(settings);\n\n        this.metadataService = metadataService ?? new MetadataService(this.settings);\n        this._claimsService = new ClaimsService(this.settings);\n        this._validator = new ResponseValidator(this.settings, this.metadataService, this._claimsService);\n        this._tokenClient = new TokenClient(this.settings, this.metadataService);\n    }\n\n    public async createSigninRequest({\n        state,\n        request,\n        request_uri,\n        request_type,\n        id_token_hint,\n        login_hint,\n        skipUserInfo,\n        nonce,\n        url_state,\n        response_type = this.settings.response_type,\n        scope = this.settings.scope,\n        redirect_uri = this.settings.redirect_uri,\n        prompt = this.settings.prompt,\n        display = this.settings.display,\n        max_age = this.settings.max_age,\n        ui_locales = this.settings.ui_locales,\n        acr_values = this.settings.acr_values,\n        resource = this.settings.resource,\n        response_mode = this.settings.response_mode,\n        extraQueryParams = this.settings.extraQueryParams,\n        extraTokenParams = this.settings.extraTokenParams,\n        dpopJkt,\n        omitScopeWhenRequesting = this.settings.omitScopeWhenRequesting,\n    }: CreateSigninRequestArgs): Promise<SigninRequest> {\n        const logger = this._logger.create(\"createSigninRequest\");\n\n        if (response_type !== \"code\") {\n            throw new Error(\"Only the Authorization Code flow (with PKCE) is supported\");\n        }\n\n        const url = await this.metadataService.getAuthorizationEndpoint();\n        logger.debug(\"Received authorization endpoint\", url);\n\n        const signinRequest = await SigninRequest.create({\n            url,\n            authority: this.settings.authority,\n            client_id: this.settings.client_id,\n            redirect_uri,\n            response_type,\n            scope,\n            state_data: state,\n            url_state,\n            prompt, display, max_age, ui_locales, id_token_hint, login_hint, acr_values, dpopJkt,\n            resource, request, request_uri, extraQueryParams, extraTokenParams, request_type, response_mode,\n            client_secret: this.settings.client_secret,\n            skipUserInfo,\n            nonce,\n            disablePKCE: this.settings.disablePKCE,\n            omitScopeWhenRequesting,\n        });\n\n        // house cleaning\n        await this.clearStaleState();\n\n        const signinState = signinRequest.state;\n        await this.settings.stateStore.set(signinState.id, signinState.toStorageString());\n        return signinRequest;\n    }\n\n    public async readSigninResponseState(url: string, removeState = false): Promise<{ state: SigninState; response: SigninResponse }> {\n        const logger = this._logger.create(\"readSigninResponseState\");\n\n        const response = new SigninResponse(UrlUtils.readParams(url, this.settings.response_mode));\n        if (!response.state) {\n            logger.throw(new Error(\"No state in response\"));\n            // need to throw within this function's body for type narrowing to work\n            // eslint-disable-next-line @typescript-eslint/only-throw-error\n            throw null; // https://github.com/microsoft/TypeScript/issues/46972\n        }\n\n        const storedStateString = await this.settings.stateStore[removeState ? \"remove\" : \"get\"](response.state);\n        if (!storedStateString) {\n            logger.throw(new Error(\"No matching state found in storage\"));\n            // eslint-disable-next-line @typescript-eslint/only-throw-error\n            throw null; // https://github.com/microsoft/TypeScript/issues/46972\n        }\n\n        const state = await SigninState.fromStorageString(storedStateString);\n        return { state, response };\n    }\n\n    public async processSigninResponse(url: string, extraHeaders?: Record<string, ExtraHeader>, removeState = true): Promise<SigninResponse> {\n        const logger = this._logger.create(\"processSigninResponse\");\n\n        const { state, response } = await this.readSigninResponseState(url, removeState);\n        logger.debug(\"received state from storage; validating response\");\n\n        if (this.settings.dpop && this.settings.dpop.store) {\n            const dpopProof = await this.getDpopProof(this.settings.dpop.store);\n            extraHeaders = { ...extraHeaders, \"DPoP\": dpopProof };\n        }\n\n        /**\n         * The DPoP spec describes a method for Authorization Servers to supply a nonce value\n         * in order to limit the lifetime of a given DPoP proof.\n         * See https://datatracker.ietf.org/doc/html/rfc9449#name-authorization-server-provid\n         * This involves the AS returning a 400 bad request with a DPoP-Nonce header containing\n         * the nonce value. The client must then retry the request with a recomputed DPoP proof\n         * containing the supplied nonce value.\n         */\n        try {\n            await this._validator.validateSigninResponse(response, state, extraHeaders);\n        }\n        catch (err) {\n            if (err instanceof ErrorDPoPNonce && this.settings.dpop) {\n                const dpopProof = await this.getDpopProof(this.settings.dpop.store, err.nonce);\n                extraHeaders![\"DPoP\"] = dpopProof;\n                await this._validator.validateSigninResponse(response, state, extraHeaders);\n            } else {\n                throw err;\n            }\n        }\n\n        return response;\n    }\n\n    async getDpopProof(dpopStore: DPoPStore, nonce?: string): Promise<string> {\n        let keyPair: CryptoKeyPair;\n        let dpopState: DPoPState;\n\n        if (!(await dpopStore.getAllKeys()).includes(this.settings.client_id)) {\n            keyPair = await CryptoUtils.generateDPoPKeys();\n            dpopState = new DPoPState(keyPair, nonce);\n            await dpopStore.set(this.settings.client_id, dpopState);\n        } else {\n            dpopState = await dpopStore.get(this.settings.client_id);\n\n            // if the server supplied nonce has changed since the last request, update the nonce\n            if (dpopState.nonce !== nonce && nonce) {\n                dpopState.nonce = nonce;\n                await dpopStore.set(this.settings.client_id, dpopState);\n            }\n        }\n\n        return await CryptoUtils.generateDPoPProof({\n            url: await this.metadataService.getTokenEndpoint(false),\n            httpMethod: \"POST\",\n            keyPair: dpopState.keys,\n            nonce: dpopState.nonce,\n        });\n    }\n\n    public async processResourceOwnerPasswordCredentials({\n        username,\n        password,\n        skipUserInfo = false,\n        extraTokenParams = {},\n    }: ProcessResourceOwnerPasswordCredentialsArgs): Promise<SigninResponse> {\n        const tokenResponse: Record<string, unknown> = await this._tokenClient.exchangeCredentials({ username, password, ...extraTokenParams });\n        const signinResponse: SigninResponse = new SigninResponse(new URLSearchParams());\n        Object.assign(signinResponse, tokenResponse);\n        await this._validator.validateCredentialsResponse(signinResponse, skipUserInfo);\n        return signinResponse;\n    }\n\n    public async useRefreshToken({\n        state,\n        redirect_uri,\n        resource,\n        timeoutInSeconds,\n        extraHeaders,\n        extraTokenParams,\n    }: UseRefreshTokenArgs): Promise<SigninResponse> {\n        const logger = this._logger.create(\"useRefreshToken\");\n\n        // https://github.com/authts/oidc-client-ts/issues/695\n        // In some cases (e.g. AzureAD), not all granted scopes are allowed on token refresh requests.\n        // Therefore, we filter all granted scopes by a list of allowable scopes.\n        let scope;\n        if (this.settings.refreshTokenAllowedScope === undefined) {\n            scope = state.scope;\n        } else {\n            const allowableScopes = this.settings.refreshTokenAllowedScope.split(\" \");\n            const providedScopes = state.scope?.split(\" \") || [];\n\n            scope = providedScopes.filter(s => allowableScopes.includes(s)).join(\" \");\n        }\n\n        if (this.settings.dpop && this.settings.dpop.store) {\n            const dpopProof = await this.getDpopProof(this.settings.dpop.store);\n            extraHeaders = { ...extraHeaders, \"DPoP\": dpopProof };\n        }\n\n        /**\n         * The DPoP spec describes a method for Authorization Servers to supply a nonce value\n         * in order to limit the lifetime of a given DPoP proof.\n         * See https://datatracker.ietf.org/doc/html/rfc9449#name-authorization-server-provid\n         * This involves the AS returning a 400 bad request with a DPoP-Nonce header containing\n         * the nonce value. The client must then retry the request with a recomputed DPoP proof\n         * containing the supplied nonce value.\n         */\n        let result;\n        try {\n            result = await this._tokenClient.exchangeRefreshToken({\n                refresh_token: state.refresh_token,\n                // provide the (possible filtered) scope list\n                scope,\n                redirect_uri,\n                resource,\n                timeoutInSeconds,\n                extraHeaders,\n                ...extraTokenParams,\n            });\n        } catch (err) {\n            if (err instanceof ErrorDPoPNonce && this.settings.dpop) {\n                extraHeaders![\"DPoP\"] = await this.getDpopProof(this.settings.dpop.store, err.nonce);\n                result = await this._tokenClient.exchangeRefreshToken({\n                    refresh_token: state.refresh_token,\n                    // provide the (possible filtered) scope list\n                    scope,\n                    redirect_uri,\n                    resource,\n                    timeoutInSeconds,\n                    extraHeaders,\n                    ...extraTokenParams,\n                });\n            } else {\n                throw err;\n            }\n        }\n\n        const response = new SigninResponse(new URLSearchParams());\n        Object.assign(response, result);\n        logger.debug(\"validating response\", response);\n        await this._validator.validateRefreshResponse(response, {\n            ...state,\n            // override the scope in the state handed over to the validator\n            // so it can set the granted scope to the requested scope in case none is included in the response\n            scope,\n        });\n        return response;\n    }\n\n    public async createSignoutRequest({\n        state,\n        id_token_hint,\n        client_id,\n        request_type,\n        url_state,\n        post_logout_redirect_uri = this.settings.post_logout_redirect_uri,\n        extraQueryParams = this.settings.extraQueryParams,\n    }: CreateSignoutRequestArgs = {}): Promise<SignoutRequest> {\n        const logger = this._logger.create(\"createSignoutRequest\");\n\n        const url = await this.metadataService.getEndSessionEndpoint();\n        if (!url) {\n            logger.throw(new Error(\"No end session endpoint\"));\n            // eslint-disable-next-line @typescript-eslint/only-throw-error\n            throw null; // https://github.com/microsoft/TypeScript/issues/46972\n        }\n\n        logger.debug(\"Received end session endpoint\", url);\n\n        // specify the client identifier when post_logout_redirect_uri is used but id_token_hint is not\n        if (!client_id && post_logout_redirect_uri && !id_token_hint) {\n            client_id = this.settings.client_id;\n        }\n\n        const request = new SignoutRequest({\n            url,\n            id_token_hint,\n            client_id,\n            post_logout_redirect_uri,\n            state_data: state,\n            extraQueryParams,\n            request_type,\n            url_state,\n        });\n\n        // house cleaning\n        await this.clearStaleState();\n\n        const signoutState = request.state;\n        if (signoutState) {\n            logger.debug(\"Signout request has state to persist\");\n            await this.settings.stateStore.set(signoutState.id, signoutState.toStorageString());\n        }\n\n        return request;\n    }\n\n    public async readSignoutResponseState(url: string, removeState = false): Promise<{ state: State | undefined; response: SignoutResponse }> {\n        const logger = this._logger.create(\"readSignoutResponseState\");\n\n        const response = new SignoutResponse(UrlUtils.readParams(url, this.settings.response_mode));\n        if (!response.state) {\n            logger.debug(\"No state in response\");\n\n            if (response.error) {\n                logger.warn(\"Response was error:\", response.error);\n                throw new ErrorResponse(response);\n            }\n\n            return { state: undefined, response };\n        }\n\n        const storedStateString = await this.settings.stateStore[removeState ? \"remove\" : \"get\"](response.state);\n        if (!storedStateString) {\n            logger.throw(new Error(\"No matching state found in storage\"));\n            // eslint-disable-next-line @typescript-eslint/only-throw-error\n            throw null; // https://github.com/microsoft/TypeScript/issues/46972\n        }\n\n        const state = await State.fromStorageString(storedStateString);\n        return { state, response };\n    }\n\n    public async processSignoutResponse(url: string): Promise<SignoutResponse> {\n        const logger = this._logger.create(\"processSignoutResponse\");\n\n        const { state, response } = await this.readSignoutResponseState(url, true);\n        if (state) {\n            logger.debug(\"Received state from storage; validating response\");\n            this._validator.validateSignoutResponse(response, state);\n        } else {\n            logger.debug(\"No state from storage; skipping response validation\");\n        }\n\n        return response;\n    }\n\n    public clearStaleState(): Promise<void> {\n        this._logger.create(\"clearStaleState\");\n        return State.clearStaleState(this.settings.stateStore, this.settings.staleStateAgeInSeconds);\n    }\n\n    public async revokeToken(token: string, type?: \"access_token\" | \"refresh_token\"): Promise<void> {\n        this._logger.create(\"revokeToken\");\n        return await this._tokenClient.revoke({\n            token,\n            token_type_hint: type,\n        });\n    }\n}\n", "// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger } from \"./utils\";\nimport { CheckSessionIFrame } from \"./CheckSessionIFrame\";\nimport type { UserManager } from \"./UserManager\";\nimport type { User } from \"./User\";\n\n/**\n * @public\n */\nexport class SessionMonitor {\n    private readonly _logger = new Logger(\"SessionMonitor\");\n\n    private _sub: string | undefined;\n    private _checkSessionIFrame?: CheckSessionIFrame;\n\n    public constructor(private readonly _userManager: UserManager) {\n        if (!_userManager) {\n            this._logger.throw(new Error(\"No user manager passed\"));\n        }\n\n        this._userManager.events.addUserLoaded(this._start);\n        this._userManager.events.addUserUnloaded(this._stop);\n\n        this._init().catch((err: unknown) => {\n            // catch to suppress errors since we're in a ctor\n            this._logger.error(err);\n        });\n    }\n\n    protected async _init(): Promise<void> {\n        this._logger.create(\"_init\");\n        const user = await this._userManager.getUser();\n        // doing this manually here since calling getUser\n        // doesn't trigger load event.\n        if (user) {\n            void this._start(user);\n        }\n        else if (this._userManager.settings.monitorAnonymousSession) {\n            const session = await this._userManager.querySessionStatus();\n            if (session) {\n                const tmpUser = {\n                    session_state: session.session_state,\n                    profile: session.sub ? {\n                        sub: session.sub,\n                    } : null,\n                };\n                void this._start(tmpUser);\n            }\n        }\n    }\n\n    protected _start = async (\n        user: User | {\n            session_state: string;\n            profile: { sub: string } | null;\n        },\n    ): Promise<void> => {\n        const session_state = user.session_state;\n        if (!session_state) {\n            return;\n        }\n        const logger = this._logger.create(\"_start\");\n\n        if (user.profile) {\n            this._sub = user.profile.sub;\n            logger.debug(\"session_state\", session_state, \", sub\", this._sub);\n        }\n        else {\n            this._sub = undefined;\n            logger.debug(\"session_state\", session_state, \", anonymous user\");\n        }\n\n        if (this._checkSessionIFrame) {\n            this._checkSessionIFrame.start(session_state);\n            return;\n        }\n\n        try {\n            const url = await this._userManager.metadataService.getCheckSessionIframe();\n            if (url) {\n                logger.debug(\"initializing check session iframe\");\n\n                const client_id = this._userManager.settings.client_id;\n                const intervalInSeconds = this._userManager.settings.checkSessionIntervalInSeconds;\n                const stopOnError = this._userManager.settings.stopCheckSessionOnError;\n\n                const checkSessionIFrame = new CheckSessionIFrame(this._callback, client_id, url, intervalInSeconds, stopOnError);\n                await checkSessionIFrame.load();\n                this._checkSessionIFrame = checkSessionIFrame;\n                checkSessionIFrame.start(session_state);\n            }\n            else {\n                logger.warn(\"no check session iframe found in the metadata\");\n            }\n        }\n        catch (err) {\n            // catch to suppress errors since we're in non-promise callback\n            logger.error(\"Error from getCheckSessionIframe:\", err instanceof Error ? err.message : err);\n        }\n    };\n\n    protected _stop = (): void => {\n        const logger = this._logger.create(\"_stop\");\n        this._sub = undefined;\n\n        if (this._checkSessionIFrame) {\n            this._checkSessionIFrame.stop();\n        }\n\n        if (this._userManager.settings.monitorAnonymousSession) {\n            // using a timer to delay re-initialization to avoid race conditions during signout\n            // TODO rewrite to use promise correctly\n            // eslint-disable-next-line @typescript-eslint/no-misused-promises\n            const timerHandle = setInterval(async () => {\n                clearInterval(timerHandle);\n\n                try {\n                    const session = await this._userManager.querySessionStatus();\n                    if (session) {\n                        const tmpUser = {\n                            session_state: session.session_state,\n                            profile: session.sub ? {\n                                sub: session.sub,\n                            } : null,\n                        };\n                        void this._start(tmpUser);\n                    }\n                }\n                catch (err) {\n                    // catch to suppress errors since we're in a callback\n                    logger.error(\"error from querySessionStatus\", err instanceof Error ? err.message : err);\n                }\n            }, 1000);\n        }\n    };\n\n    protected _callback = async (): Promise<void> => {\n        const logger = this._logger.create(\"_callback\");\n        try {\n            const session = await this._userManager.querySessionStatus();\n            let raiseEvent = true;\n\n            if (session && this._checkSessionIFrame) {\n                if (session.sub === this._sub) {\n                    raiseEvent = false;\n                    this._checkSessionIFrame.start(session.session_state);\n\n                    logger.debug(\"same sub still logged in at OP, session state has changed, restarting check session iframe; session_state\", session.session_state);\n                    await this._userManager.events._raiseUserSessionChanged();\n                }\n                else {\n                    logger.debug(\"different subject signed into OP\", session.sub);\n                }\n            }\n            else {\n                logger.debug(\"subject no longer signed into OP\");\n            }\n\n            if (raiseEvent) {\n                if (this._sub) {\n                    await this._userManager.events._raiseUserSignedOut();\n                }\n                else {\n                    await this._userManager.events._raiseUserSignedIn();\n                }\n            } else {\n                logger.debug(\"no change in session detected, no event to raise\");\n            }\n        }\n        catch (err) {\n            if (this._sub) {\n                logger.debug(\"Error calling queryCurrentSigninSession; raising signed out event\", err);\n                await this._userManager.events._raiseUserSignedOut();\n            }\n        }\n    };\n}\n", "// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger, Timer } from \"./utils\";\nimport type { IdTokenClaims } from \"./Claims\";\n\n/**\n * Holds claims represented by a combination of the `id_token` and the user info endpoint.\n *\n * @public\n */\nexport type UserProfile = IdTokenClaims;\n\n/**\n * @public\n */\nexport class User {\n    /**\n     * A JSON Web Token (JWT). Only provided if `openid` scope was requested.\n     * The application can access the data decoded by using the `profile` property.\n     */\n    public id_token?: string;\n\n    /** The session state value returned from the OIDC provider. */\n    public session_state: string | null;\n\n    /**\n     * The requested access token returned from the OIDC provider. The application can use this token to\n     * authenticate itself to the secured resource.\n     */\n    public access_token: string;\n\n    /**\n     * An OAuth 2.0 refresh token. The app can use this token to acquire additional access tokens after the\n     * current access token expires. Refresh tokens are long-lived and can be used to maintain access to resources\n     * for extended periods of time.\n     */\n    public refresh_token?: string;\n\n    /** Typically \"Bearer\" */\n    public token_type: string;\n\n    /** The scopes that the requested access token is valid for. */\n    public scope?: string;\n\n    /** The claims represented by a combination of the `id_token` and the user info endpoint. */\n    public profile: UserProfile;\n\n    /** The expires at returned from the OIDC provider. */\n    public expires_at?: number;\n\n    /** custom state data set during the initial signin request */\n    public readonly state: unknown;\n    public readonly url_state?: string;\n\n    public constructor(args: {\n        id_token?: string;\n        session_state?: string | null;\n        access_token: string;\n        refresh_token?: string;\n        token_type: string;\n        scope?: string;\n        profile: UserProfile;\n        expires_at?: number;\n        userState?: unknown;\n        url_state?: string;\n    }) {\n        this.id_token = args.id_token;\n        this.session_state = args.session_state ?? null;\n        this.access_token = args.access_token;\n        this.refresh_token = args.refresh_token;\n\n        this.token_type = args.token_type;\n        this.scope = args.scope;\n        this.profile = args.profile;\n        this.expires_at = args.expires_at;\n        this.state = args.userState;\n        this.url_state = args.url_state;\n    }\n\n    /** Computed number of seconds the access token has remaining. */\n    public get expires_in(): number | undefined {\n        if (this.expires_at === undefined) {\n            return undefined;\n        }\n        return this.expires_at - Timer.getEpochTime();\n    }\n\n    public set expires_in(value: number | undefined) {\n        if (value !== undefined) {\n            this.expires_at = Math.floor(value) + Timer.getEpochTime();\n        }\n    }\n\n    /** Computed value indicating if the access token is expired. */\n    public get expired(): boolean | undefined {\n        const expires_in = this.expires_in;\n        if (expires_in === undefined) {\n            return undefined;\n        }\n        return expires_in <= 0;\n    }\n\n    /** Array representing the parsed values from the `scope`. */\n    public get scopes(): string[] {\n        return this.scope?.split(\" \") ?? [];\n    }\n\n    public toStorageString(): string {\n        new Logger(\"User\").create(\"toStorageString\");\n        return JSON.stringify({\n            id_token: this.id_token,\n            session_state: this.session_state,\n            access_token: this.access_token,\n            refresh_token: this.refresh_token,\n            token_type: this.token_type,\n            scope: this.scope,\n            profile: this.profile,\n            expires_at: this.expires_at,\n        });\n    }\n\n    public static fromStorageString(storageString: string): User {\n        Logger.createStatic(\"User\", \"fromStorageString\");\n        return new User(JSON.parse(storageString));\n    }\n}\n", "// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Event, Logger, UrlUtils } from \"../utils\";\nimport type { IWindow, NavigateParams, NavigateResponse } from \"./IWindow\";\n\nconst messageSource = \"oidc-client\";\n\ninterface MessageData {\n    source: string;\n    url: string;\n    keepOpen: boolean;\n}\n\n/**\n * Window implementation which resolves via communication from a child window\n * via the `Window.postMessage()` interface.\n *\n * @internal\n */\nexport abstract class AbstractChildWindow implements IWindow {\n    protected abstract readonly _logger: Logger;\n    protected readonly _abort = new Event<[reason: Error]>(\"Window navigation aborted\");\n    protected readonly _disposeHandlers = new Set<() => void>();\n\n    protected _window: WindowProxy | null = null;\n\n    public async navigate(params: NavigateParams): Promise<NavigateResponse> {\n        const logger = this._logger.create(\"navigate\");\n        if (!this._window) {\n            throw new Error(\"Attempted to navigate on a disposed window\");\n        }\n\n        logger.debug(\"setting URL in window\");\n        this._window.location.replace(params.url);\n\n        const { url, keepOpen } = await new Promise<MessageData>((resolve, reject) => {\n            const listener = (e: MessageEvent) => {\n                const data: MessageData | undefined = e.data;\n                const origin = params.scriptOrigin ?? window.location.origin;\n                if (e.origin !== origin || data?.source !== messageSource) {\n                    // silently discard events not intended for us\n                    return;\n                }\n                try {\n                    const state = UrlUtils.readParams(data.url, params.response_mode).get(\"state\");\n                    if (!state) {\n                        logger.warn(\"no state found in response url\");\n                    }\n                    if (e.source !== this._window && state !== params.state) {\n                        // MessageEvent source is a relatively modern feature, we can't rely on it\n                        // so we also inspect the payload for a matching state key as an alternative\n                        return;\n                    }\n                }\n                catch {\n                    this._dispose();\n                    reject(new Error(\"Invalid response from window\"));\n                }\n                resolve(data);\n            };\n            window.addEventListener(\"message\", listener, false);\n            this._disposeHandlers.add(() => window.removeEventListener(\"message\", listener, false));\n            const channel = new BroadcastChannel(`oidc-client-popup-${params.state}`);\n            channel.addEventListener(\"message\", listener, false);\n            this._disposeHandlers.add(() => channel.close());\n            this._disposeHandlers.add(this._abort.addHandler((reason) => {\n                this._dispose();\n                reject(reason);\n            }));\n        });\n        logger.debug(\"got response from window\");\n        this._dispose();\n\n        if (!keepOpen) {\n            this.close();\n        }\n\n        return { url };\n    }\n\n    public abstract close(): void;\n\n    private _dispose(): void {\n        this._logger.create(\"_dispose\");\n\n        for (const dispose of this._disposeHandlers) {\n            dispose();\n        }\n        this._disposeHandlers.clear();\n    }\n\n    protected static _notifyParent(parent: Window | null, url: string, keepOpen = false, targetOrigin = window.location.origin): void {\n        const msgData: MessageData = {\n            source: messageSource,\n            url,\n            keepOpen,\n        };\n        const logger = new Logger(\"_notifyParent\");\n        if (parent) {\n            logger.debug(\"With parent. Using parent.postMessage.\");\n            parent.postMessage(msgData, targetOrigin);\n        } else {\n            logger.debug(\"No parent. Using BroadcastChannel.\");\n            const state = new URL(url).searchParams.get(\"state\");\n            if (!state) {\n                throw new Error(\"No parent and no state in URL. Can't complete notification.\");\n            }\n            const channel = new BroadcastChannel(`oidc-client-popup-${state}`);\n            channel.postMessage(msgData);\n            channel.close();\n        }\n    }\n}\n", "// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { type OidcClientSettings, OidcClientSettingsStore } from \"./OidcClientSettings\";\nimport type { PopupWindowFeatures } from \"./utils/PopupUtils\";\nimport { WebStorageStateStore } from \"./WebStorageStateStore\";\nimport { InMemoryWebStorage } from \"./InMemoryWebStorage\";\nimport type { StateStore } from \"./StateStore\";\n\nexport const DefaultPopupWindowFeatures: PopupWindowFeatures = {\n    location: false,\n    toolbar: false,\n    height: 640,\n    closePopupWindowAfterInSeconds: -1,\n};\nexport const DefaultPopupTarget = \"_blank\";\nconst DefaultAccessTokenExpiringNotificationTimeInSeconds = 60;\nconst DefaultCheckSessionIntervalInSeconds = 2;\nexport const DefaultSilentRequestTimeoutInSeconds = 10;\n\n/**\n * The settings used to configure the {@link UserManager}.\n *\n * @public\n */\nexport interface UserManagerSettings extends OidcClientSettings {\n    /** The URL for the page containing the call to signinPopupCallback to handle the callback from the OIDC/OAuth2 */\n    popup_redirect_uri?: string;\n    popup_post_logout_redirect_uri?: string;\n    /**\n     * The features parameter to window.open for the popup signin window. By default, the popup is\n     * placed centered in front of the window opener.\n     * (default: \\{ location: false, menubar: false, height: 640, closePopupWindowAfterInSeconds: -1 \\})\n     */\n    popupWindowFeatures?: PopupWindowFeatures;\n    /** The target parameter to window.open for the popup signin window (default: \"_blank\") */\n    popupWindowTarget?: string;\n    /** The methods window.location method used to redirect (default: \"assign\") */\n    redirectMethod?: \"replace\" | \"assign\";\n    /** The methods target window being redirected (default: \"self\") */\n    redirectTarget?: \"top\" | \"self\";\n\n    /** The target to pass while calling postMessage inside iframe for callback (default: window.location.origin) */\n    iframeNotifyParentOrigin?: string;\n\n    /** The script origin to check during 'message' callback execution while performing silent auth via iframe (default: window.location.origin) */\n    iframeScriptOrigin?: string;\n\n    /** The URL for the page containing the code handling the silent renew */\n    silent_redirect_uri?: string;\n    /** Number of seconds to wait for the silent renew to return before assuming it has failed or timed out (default: 10) */\n    silentRequestTimeoutInSeconds?: number;\n    /** Flag to indicate if there should be an automatic attempt to renew the access token prior to its expiration. The automatic renew attempt starts 1 minute before the access token expires (default: true) */\n    automaticSilentRenew?: boolean;\n    /** Flag to validate user.profile.sub in silent renew calls (default: true) */\n    validateSubOnSilentRenew?: boolean;\n    /** Flag to control if id_token is included as id_token_hint in silent renew calls (default: false) */\n    includeIdTokenInSilentRenew?: boolean;\n\n    /** Will raise events for when user has performed a signout at the OP (default: false) */\n    monitorSession?: boolean;\n    monitorAnonymousSession?: boolean;\n    /** Interval in seconds to check the user's session (default: 2) */\n    checkSessionIntervalInSeconds?: number;\n    query_status_response_type?: string;\n    stopCheckSessionOnError?: boolean;\n\n    /**\n     * The `token_type_hint`s to pass to the authority server by default (default: [\"access_token\", \"refresh_token\"])\n     *\n     * Token types will be revoked in the same order as they are given here.\n     */\n    revokeTokenTypes?: (\"access_token\" | \"refresh_token\")[];\n    /** Will invoke the revocation endpoint on signout if there is an access token for the user (default: false) */\n    revokeTokensOnSignout?: boolean;\n    /** Flag to control if id_token is included as id_token_hint in silent signout calls (default: false) */\n    includeIdTokenInSilentSignout?: boolean;\n\n    /** The number of seconds before an access token is to expire to raise the accessTokenExpiring event (default: 60) */\n    accessTokenExpiringNotificationTimeInSeconds?: number;\n\n    /**\n     * Storage object used to persist User for currently authenticated user (default: window.sessionStorage, InMemoryWebStorage iff no window).\n     *  E.g. `userStore: new WebStorageStateStore({ store: window.localStorage })`\n     */\n    userStore?: StateStore;\n}\n\n/**\n * The settings with defaults applied of the {@link UserManager}.\n * @see {@link UserManagerSettings}\n *\n * @public\n */\nexport class UserManagerSettingsStore extends OidcClientSettingsStore {\n    public readonly popup_redirect_uri: string;\n    public readonly popup_post_logout_redirect_uri: string | undefined;\n    public readonly popupWindowFeatures: PopupWindowFeatures;\n    public readonly popupWindowTarget: string;\n    public readonly redirectMethod: \"replace\" | \"assign\";\n    public readonly redirectTarget: \"top\" | \"self\";\n\n    public readonly iframeNotifyParentOrigin: string | undefined;\n    public readonly iframeScriptOrigin: string | undefined;\n\n    public readonly silent_redirect_uri: string;\n    public readonly silentRequestTimeoutInSeconds: number;\n    public readonly automaticSilentRenew: boolean;\n    public readonly validateSubOnSilentRenew: boolean;\n    public readonly includeIdTokenInSilentRenew: boolean;\n\n    public readonly monitorSession: boolean;\n    public readonly monitorAnonymousSession: boolean;\n    public readonly checkSessionIntervalInSeconds: number;\n    public readonly query_status_response_type: string;\n    public readonly stopCheckSessionOnError: boolean;\n\n    public readonly revokeTokenTypes: (\"access_token\" | \"refresh_token\")[];\n    public readonly revokeTokensOnSignout: boolean;\n    public readonly includeIdTokenInSilentSignout: boolean;\n\n    public readonly accessTokenExpiringNotificationTimeInSeconds: number;\n\n    public readonly userStore: StateStore;\n\n    public constructor(args: UserManagerSettings) {\n        const {\n            popup_redirect_uri = args.redirect_uri,\n            popup_post_logout_redirect_uri = args.post_logout_redirect_uri,\n            popupWindowFeatures = DefaultPopupWindowFeatures,\n            popupWindowTarget = DefaultPopupTarget,\n            redirectMethod = \"assign\",\n            redirectTarget = \"self\",\n\n            iframeNotifyParentOrigin = args.iframeNotifyParentOrigin,\n            iframeScriptOrigin = args.iframeScriptOrigin,\n\n            requestTimeoutInSeconds,\n            silent_redirect_uri = args.redirect_uri,\n            silentRequestTimeoutInSeconds,\n            automaticSilentRenew = true,\n            validateSubOnSilentRenew = true,\n            includeIdTokenInSilentRenew = false,\n\n            monitorSession = false,\n            monitorAnonymousSession = false,\n            checkSessionIntervalInSeconds = DefaultCheckSessionIntervalInSeconds,\n            query_status_response_type = \"code\",\n            stopCheckSessionOnError = true,\n\n            revokeTokenTypes = [\"access_token\", \"refresh_token\"],\n            revokeTokensOnSignout = false,\n            includeIdTokenInSilentSignout = false,\n\n            accessTokenExpiringNotificationTimeInSeconds = DefaultAccessTokenExpiringNotificationTimeInSeconds,\n\n            userStore,\n        } = args;\n\n        super(args);\n\n        this.popup_redirect_uri = popup_redirect_uri;\n        this.popup_post_logout_redirect_uri = popup_post_logout_redirect_uri;\n        this.popupWindowFeatures = popupWindowFeatures;\n        this.popupWindowTarget = popupWindowTarget;\n        this.redirectMethod = redirectMethod;\n        this.redirectTarget = redirectTarget;\n\n        this.iframeNotifyParentOrigin = iframeNotifyParentOrigin;\n        this.iframeScriptOrigin = iframeScriptOrigin;\n\n        this.silent_redirect_uri = silent_redirect_uri;\n        this.silentRequestTimeoutInSeconds = silentRequestTimeoutInSeconds || requestTimeoutInSeconds || DefaultSilentRequestTimeoutInSeconds;\n        this.automaticSilentRenew = automaticSilentRenew;\n        this.validateSubOnSilentRenew = validateSubOnSilentRenew;\n        this.includeIdTokenInSilentRenew = includeIdTokenInSilentRenew;\n\n        this.monitorSession = monitorSession;\n        this.monitorAnonymousSession = monitorAnonymousSession;\n        this.checkSessionIntervalInSeconds = checkSessionIntervalInSeconds;\n        this.stopCheckSessionOnError = stopCheckSessionOnError;\n        this.query_status_response_type = query_status_response_type;\n\n        this.revokeTokenTypes = revokeTokenTypes;\n        this.revokeTokensOnSignout = revokeTokensOnSignout;\n        this.includeIdTokenInSilentSignout = includeIdTokenInSilentSignout;\n\n        this.accessTokenExpiringNotificationTimeInSeconds = accessTokenExpiringNotificationTimeInSeconds;\n\n        if (userStore) {\n            this.userStore = userStore;\n        }\n        else {\n            const store = typeof window !== \"undefined\" ? window.sessionStorage : new InMemoryWebStorage();\n            this.userStore = new WebStorageStateStore({ store });\n        }\n    }\n}\n", "// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger } from \"../utils\";\nimport { ErrorTimeout } from \"../errors\";\nimport type { NavigateParams, NavigateResponse } from \"./IWindow\";\nimport { AbstractChildWindow } from \"./AbstractChildWindow\";\nimport { DefaultSilentRequestTimeoutInSeconds } from \"../UserManagerSettings\";\n\n/**\n * @public\n */\nexport interface IFrameWindowParams {\n    silentRequestTimeoutInSeconds?: number;\n}\n\n/**\n * @internal\n */\nexport class IFrameWindow extends AbstractChildWindow {\n    protected readonly _logger = new Logger(\"IFrameWindow\");\n    private _frame: HTMLIFrameElement | null;\n    private _timeoutInSeconds: number;\n\n    public constructor({\n        silentRequestTimeoutInSeconds = DefaultSilentRequestTimeoutInSeconds,\n    }: IFrameWindowParams) {\n        super();\n        this._timeoutInSeconds = silentRequestTimeoutInSeconds;\n\n        this._frame = IFrameWindow.createHiddenIframe();\n        this._window = this._frame.contentWindow;\n    }\n\n    private static createHiddenIframe(): HTMLIFrameElement {\n        const iframe = window.document.createElement(\"iframe\");\n\n        // shotgun approach\n        iframe.style.visibility = \"hidden\";\n        iframe.style.position = \"fixed\";\n        iframe.style.left = \"-1000px\";\n        iframe.style.top = \"0\";\n        iframe.width = \"0\";\n        iframe.height = \"0\";\n\n        window.document.body.appendChild(iframe);\n        return iframe;\n    }\n\n    public async navigate(params: NavigateParams): Promise<NavigateResponse> {\n        this._logger.debug(\"navigate: Using timeout of:\", this._timeoutInSeconds);\n        const timer = setTimeout(() => void this._abort.raise(new ErrorTimeout(\"IFrame timed out without a response\")), this._timeoutInSeconds * 1000);\n        this._disposeHandlers.add(() => clearTimeout(timer));\n\n        return await super.navigate(params);\n    }\n\n    public close(): void {\n        if (this._frame) {\n            if (this._frame.parentNode) {\n                this._frame.addEventListener(\"load\", (ev) => {\n                    const frame = ev.target as HTMLIFrameElement;\n                    frame.parentNode?.removeChild(frame);\n                    void this._abort.raise(new Error(\"IFrame removed from DOM\"));\n                }, true);\n                this._frame.contentWindow?.location.replace(\"about:blank\");\n            }\n            this._frame = null;\n        }\n        this._window = null;\n    }\n\n    public static notifyParent(url: string, targetOrigin?: string): void {\n        return super._notifyParent(window.parent, url, false, targetOrigin);\n    }\n}\n", "// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger } from \"../utils\";\nimport type { UserManagerSettingsStore } from \"../UserManagerSettings\";\nimport { IFrameWindow, type IFrameWindowParams } from \"./IFrameWindow\";\nimport type { INavigator } from \"./INavigator\";\n\n/**\n * @internal\n */\nexport class IFrameNavigator implements INavigator {\n    private readonly _logger = new Logger(\"IFrameNavigator\");\n\n    constructor(private _settings: UserManagerSettingsStore) {}\n\n    public async prepare({\n        silentRequestTimeoutInSeconds = this._settings.silentRequestTimeoutInSeconds,\n    }: IFrameWindowParams): Promise<IFrameWindow> {\n        return new IFrameWindow({ silentRequestTimeoutInSeconds });\n    }\n\n    public async callback(url: string): Promise<void> {\n        this._logger.create(\"callback\");\n        IFrameWindow.notifyParent(url, this._settings.iframeNotifyParentOrigin);\n    }\n}\n", "// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger, PopupUtils, type PopupWindowFeatures } from \"../utils\";\nimport { DefaultPopupWindowFeatures, DefaultPopupTarget } from \"../UserManagerSettings\";\nimport { AbstractChildWindow } from \"./AbstractChildWindow\";\nimport type { NavigateParams, NavigateResponse } from \"./IWindow\";\n\nconst checkForPopupClosedInterval = 500;\nconst second = 1000;\n\n/**\n * @public\n */\nexport interface PopupWindowParams {\n    popupWindowFeatures?: PopupWindowFeatures;\n    popupWindowTarget?: string;\n    /** An AbortSignal to set request's signal. */\n    popupSignal?: AbortSignal | null;\n}\n\n/**\n * @internal\n */\nexport class PopupWindow extends AbstractChildWindow {\n    protected readonly _logger = new Logger(\"PopupWindow\");\n\n    protected _window: WindowProxy | null;\n\n    public constructor({\n        popupWindowTarget = DefaultPopupTarget,\n        popupWindowFeatures = {},\n        popupSignal,\n    }: PopupWindowParams) {\n        super();\n        const centeredPopup = PopupUtils.center({ ...DefaultPopupWindowFeatures, ...popupWindowFeatures });\n        this._window = window.open(undefined, popupWindowTarget, PopupUtils.serialize(centeredPopup));\n\n        if (popupSignal) {\n            popupSignal.addEventListener(\"abort\", () => {\n                void this._abort.raise(new Error(popupSignal.reason ?? \"Popup aborted\"));\n            });\n        }\n\n        if (popupWindowFeatures.closePopupWindowAfterInSeconds && popupWindowFeatures.closePopupWindowAfterInSeconds > 0) {\n            setTimeout(() => {\n                if (!this._window || typeof this._window.closed !== \"boolean\" || this._window.closed) {\n                    void this._abort.raise(new Error(\"Popup blocked by user\"));\n                    return;\n                }\n\n                this.close();\n            }, popupWindowFeatures.closePopupWindowAfterInSeconds * second);\n        }\n    }\n\n    public async navigate(params: NavigateParams): Promise<NavigateResponse> {\n        this._window?.focus();\n\n        const popupClosedInterval = setInterval(() => {\n            if (!this._window || this._window.closed) {\n                this._logger.debug(\"Popup closed by user or isolated by redirect\");\n                clearPopupClosedInterval();\n                this._disposeHandlers.delete(clearPopupClosedInterval);\n            }\n        }, checkForPopupClosedInterval);\n        const clearPopupClosedInterval = () => clearInterval(popupClosedInterval);\n        this._disposeHandlers.add(clearPopupClosedInterval);\n\n        return await super.navigate(params);\n    }\n\n    public close(): void {\n        if (this._window) {\n            if (!this._window.closed) {\n                this._window.close();\n                void this._abort.raise(new Error(\"Popup closed\"));\n            }\n        }\n        this._window = null;\n    }\n\n    public static notifyOpener(url: string, keepOpen: boolean): void {\n        super._notifyParent(window.opener, url, keepOpen);\n        if (!keepOpen && !window.opener) {\n            window.close();\n        }\n    }\n}\n", "// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger } from \"../utils\";\nimport { PopupWindow, type PopupWindowParams } from \"./PopupWindow\";\nimport type { INavigator } from \"./INavigator\";\nimport type { UserManagerSettingsStore } from \"../UserManagerSettings\";\n\n/**\n * @internal\n */\nexport class PopupNavigator implements INavigator {\n    private readonly _logger = new Logger(\"PopupNavigator\");\n\n    constructor(private _settings: UserManagerSettingsStore) { }\n\n    public async prepare({\n        popupWindowFeatures = this._settings.popupWindowFeatures,\n        popupWindowTarget = this._settings.popupWindowTarget,\n        popupSignal,\n    }: PopupWindowParams): Promise<PopupWindow> {\n        return new PopupWindow({ popupWindowFeatures, popupWindowTarget, popupSignal });\n    }\n\n    public async callback(url: string, { keepOpen = false }): Promise<void> {\n        this._logger.create(\"callback\");\n\n        PopupWindow.notifyOpener(url, keepOpen);\n    }\n}\n", "// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger } from \"../utils\";\nimport type { UserManagerSettingsStore } from \"../UserManagerSettings\";\nimport type { INavigator } from \"./INavigator\";\nimport type { IWindow } from \"./IWindow\";\n\n/**\n * @public\n */\nexport interface RedirectParams {\n    redirectMethod?: \"replace\" | \"assign\";\n    redirectTarget?: \"top\" | \"self\";\n}\n\n/**\n * @internal\n */\nexport class RedirectNavigator implements INavigator {\n    private readonly _logger = new Logger(\"RedirectNavigator\");\n\n    constructor(private _settings: UserManagerSettingsStore) {}\n\n    public async prepare({\n        redirectMethod = this._settings.redirectMethod,\n        redirectTarget = this._settings.redirectTarget,\n    }: RedirectParams): Promise<IWindow> {\n        this._logger.create(\"prepare\");\n        let targetWindow = window.self as Window;\n\n        if (redirectTarget === \"top\") {\n            targetWindow = window.top ?? window.self;\n        }\n    \n        const redirect = targetWindow.location[redirectMethod].bind(targetWindow.location) as (url: string) => never;\n        let abort: (reason: Error) => void;\n        return {\n            navigate: async (params): Promise<never> => {\n                this._logger.create(\"navigate\");\n                // We use a promise that never resolves to block the caller\n                const promise = new Promise((resolve, reject) => {\n                    abort = reject;\n                });\n                redirect(params.url);\n                return await (promise as Promise<never>);\n            },\n            close: () => {\n                this._logger.create(\"close\");\n                abort?.(new Error(\"Redirect aborted\"));\n                targetWindow.stop();\n            },\n        };\n    }\n\n    public async callback(): Promise<void> {\n        return;\n    }\n}\n", "// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger, Event } from \"./utils\";\nimport { AccessTokenEvents } from \"./AccessTokenEvents\";\nimport type { UserManagerSettingsStore } from \"./UserManagerSettings\";\nimport type { User } from \"./User\";\n\n/**\n * @public\n */\nexport type UserLoadedCallback = (user: User) => Promise<void> | void;\n/**\n * @public\n */\nexport type UserUnloadedCallback = () => Promise<void> | void;\n/**\n * @public\n */\nexport type SilentRenewErrorCallback = (error: Error) => Promise<void> | void;\n/**\n * @public\n */\nexport type UserSignedInCallback = () => Promise<void> | void;\n/**\n * @public\n */\nexport type UserSignedOutCallback = () => Promise<void> | void;\n/**\n * @public\n */\nexport type UserSessionChangedCallback = () => Promise<void> | void;\n\n/**\n * @public\n */\nexport class UserManagerEvents extends AccessTokenEvents {\n    protected readonly _logger = new Logger(\"UserManagerEvents\");\n\n    private readonly _userLoaded = new Event<[User]>(\"User loaded\");\n    private readonly _userUnloaded = new Event<[]>(\"User unloaded\");\n    private readonly _silentRenewError = new Event<[Error]>(\"Silent renew error\");\n    private readonly _userSignedIn = new Event<[]>(\"User signed in\");\n    private readonly _userSignedOut = new Event<[]>(\"User signed out\");\n    private readonly _userSessionChanged = new Event<[]>(\"User session changed\");\n\n    public constructor(settings: UserManagerSettingsStore) {\n        super({ expiringNotificationTimeInSeconds: settings.accessTokenExpiringNotificationTimeInSeconds });\n    }\n\n    public async load(user: User, raiseEvent=true): Promise<void> {\n        await super.load(user);\n        if (raiseEvent) {\n            await this._userLoaded.raise(user);\n        }\n    }\n\n    public async unload(): Promise<void> {\n        await super.unload();\n        await this._userUnloaded.raise();\n    }\n\n    /**\n     * Add callback: Raised when a user session has been established (or re-established).\n     */\n    public addUserLoaded(cb: UserLoadedCallback): () => void {\n        return this._userLoaded.addHandler(cb);\n    }\n    /**\n     * Remove callback: Raised when a user session has been established (or re-established).\n     */\n    public removeUserLoaded(cb: UserLoadedCallback): void {\n        return this._userLoaded.removeHandler(cb);\n    }\n\n    /**\n     * Add callback: Raised when a user session has been terminated.\n     */\n    public addUserUnloaded(cb: UserUnloadedCallback): () => void {\n        return this._userUnloaded.addHandler(cb);\n    }\n    /**\n     * Remove callback: Raised when a user session has been terminated.\n     */\n    public removeUserUnloaded(cb: UserUnloadedCallback): void {\n        return this._userUnloaded.removeHandler(cb);\n    }\n\n    /**\n     * Add callback: Raised when the automatic silent renew has failed.\n     */\n    public addSilentRenewError(cb: SilentRenewErrorCallback): () => void {\n        return this._silentRenewError.addHandler(cb);\n    }\n    /**\n     * Remove callback: Raised when the automatic silent renew has failed.\n     */\n    public removeSilentRenewError(cb: SilentRenewErrorCallback): void {\n        return this._silentRenewError.removeHandler(cb);\n    }\n    /**\n     * @internal\n     */\n    public async _raiseSilentRenewError(e: Error): Promise<void> {\n        await this._silentRenewError.raise(e);\n    }\n\n    /**\n     * Add callback: Raised when the user is signed in (when `monitorSession` is set).\n     * @see {@link UserManagerSettings.monitorSession}\n     */\n    public addUserSignedIn(cb: UserSignedInCallback): () => void {\n        return this._userSignedIn.addHandler(cb);\n    }\n    /**\n     * Remove callback: Raised when the user is signed in (when `monitorSession` is set).\n     */\n    public removeUserSignedIn(cb: UserSignedInCallback): void {\n        this._userSignedIn.removeHandler(cb);\n    }\n    /**\n     * @internal\n     */\n    public async _raiseUserSignedIn(): Promise<void> {\n        await this._userSignedIn.raise();\n    }\n\n    /**\n     * Add callback: Raised when the user's sign-in status at the OP has changed (when `monitorSession` is set).\n     * @see {@link UserManagerSettings.monitorSession}\n     */\n    public addUserSignedOut(cb: UserSignedOutCallback): () => void {\n        return this._userSignedOut.addHandler(cb);\n    }\n    /**\n     * Remove callback: Raised when the user's sign-in status at the OP has changed (when `monitorSession` is set).\n     */\n    public removeUserSignedOut(cb: UserSignedOutCallback): void {\n        this._userSignedOut.removeHandler(cb);\n    }\n    /**\n     * @internal\n     */\n    public async _raiseUserSignedOut(): Promise<void> {\n        await this._userSignedOut.raise();\n    }\n\n    /**\n     * Add callback: Raised when the user session changed (when `monitorSession` is set).\n     * @see {@link UserManagerSettings.monitorSession}\n     */\n    public addUserSessionChanged(cb: UserSessionChangedCallback): () => void {\n        return this._userSessionChanged.addHandler(cb);\n    }\n    /**\n     * Remove callback: Raised when the user session changed (when `monitorSession` is set).\n     */\n    public removeUserSessionChanged(cb: UserSessionChangedCallback): void {\n        this._userSessionChanged.removeHandler(cb);\n    }\n    /**\n     * @internal\n     */\n    public async _raiseUserSessionChanged(): Promise<void> {\n        await this._userSessionChanged.raise();\n    }\n}\n", "// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger, Timer } from \"./utils\";\nimport { ErrorTimeout } from \"./errors\";\nimport type { UserManager } from \"./UserManager\";\nimport type { AccessTokenCallback } from \"./AccessTokenEvents\";\n\n/**\n * @internal\n */\nexport class SilentRenewService {\n    protected _logger = new Logger(\"SilentRenewService\");\n    private _isStarted = false;\n    private readonly _retryTimer = new Timer(\"Retry Silent Renew\");\n\n    public constructor(private _userManager: UserManager) {}\n\n    public async start(): Promise<void> {\n        const logger = this._logger.create(\"start\");\n        if (!this._isStarted) {\n            this._isStarted = true;\n            this._userManager.events.addAccessTokenExpiring(this._tokenExpiring);\n            this._retryTimer.addHandler(this._tokenExpiring);\n\n            // this will trigger loading of the user so the expiring events can be initialized\n            try {\n                await this._userManager.getUser();\n                // deliberate nop\n            }\n            catch (err) {\n                // catch to suppress errors since we're in a ctor\n                logger.error(\"getUser error\", err);\n            }\n        }\n    }\n\n    public stop(): void {\n        if (this._isStarted) {\n            this._retryTimer.cancel();\n            this._retryTimer.removeHandler(this._tokenExpiring);\n            this._userManager.events.removeAccessTokenExpiring(this._tokenExpiring);\n            this._isStarted = false;\n        }\n    }\n\n    protected _tokenExpiring: AccessTokenCallback = async () => {\n        const logger = this._logger.create(\"_tokenExpiring\");\n        try {\n            await this._userManager.signinSilent();\n            logger.debug(\"silent token renewal successful\");\n        }\n        catch (err) {\n            if (err instanceof ErrorTimeout) {\n                // no response from authority server, e.g. IFrame timeout, ...\n                logger.warn(\"ErrorTimeout from signinSilent:\", err, \"retry in 5s\");\n                this._retryTimer.init(5);\n                return;\n            }\n\n            logger.error(\"Error from signinSilent:\", err);\n            await this._userManager.events._raiseSilentRenewError(err as Error);\n        }\n    };\n}\n", "// Copyright (C) AuthTS Contributors\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport type { UserProfile } from \"./User\";\n\n/**\n * Fake state store implementation necessary for validating refresh token requests.\n *\n * @public\n */\nexport class RefreshState {\n    /** custom \"state\", which can be used by a caller to have \"data\" round tripped */\n    public readonly data?: unknown;\n\n    public readonly refresh_token: string;\n    public readonly id_token?: string;\n    public readonly session_state: string | null;\n    public readonly scope?: string;\n    public readonly profile: UserProfile;\n\n    constructor(args: {\n        refresh_token: string;\n        id_token?: string;\n        session_state: string | null;\n        scope?: string;\n        profile: UserProfile;\n\n        state?: unknown;\n    }) {\n        this.refresh_token = args.refresh_token;\n        this.id_token = args.id_token;\n        this.session_state = args.session_state;\n        this.scope = args.scope;\n        this.profile = args.profile;\n\n        this.data = args.state;\n\n    }\n}\n", "// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { CryptoUtils, Logger } from \"./utils\";\nimport { ErrorResponse } from \"./errors\";\nimport { type NavigateResponse, type PopupWindowParams, type IWindow, type IFrameWindowParams, type RedirectParams, RedirectNavigator, PopupNavigator, IFrameNavigator, type INavigator } from \"./navigators\";\nimport { OidcClient, type CreateSigninRequestArgs, type CreateSignoutRequestArgs, type ProcessResourceOwnerPasswordCredentialsArgs, type UseRefreshTokenArgs } from \"./OidcClient\";\nimport { type UserManagerSettings, UserManagerSettingsStore } from \"./UserManagerSettings\";\nimport { User } from \"./User\";\nimport { UserManagerEvents } from \"./UserManagerEvents\";\nimport { SilentRenewService } from \"./SilentRenewService\";\nimport { SessionMonitor } from \"./SessionMonitor\";\nimport type { SessionStatus } from \"./SessionStatus\";\nimport type { SignoutResponse } from \"./SignoutResponse\";\nimport type { MetadataService } from \"./MetadataService\";\nimport { RefreshState } from \"./RefreshState\";\nimport type { SigninResponse } from \"./SigninResponse\";\nimport type { ExtraHeader, DPoPSettings } from \"./OidcClientSettings\";\nimport { DPoPState } from \"./DPoPStore\";\n\n/**\n * @public\n */\nexport type ExtraSigninRequestArgs = Pick<CreateSigninRequestArgs, \"nonce\" | \"extraQueryParams\" | \"extraTokenParams\" | \"state\" | \"redirect_uri\" | \"prompt\" | \"acr_values\" | \"login_hint\" | \"scope\" | \"max_age\" | \"ui_locales\" | \"resource\" | \"url_state\">;\n/**\n * @public\n */\nexport type ExtraSignoutRequestArgs = Pick<CreateSignoutRequestArgs, \"extraQueryParams\" | \"state\" | \"id_token_hint\" | \"post_logout_redirect_uri\" | \"url_state\">;\n\n/**\n * @public\n */\nexport type RevokeTokensTypes = UserManagerSettings[\"revokeTokenTypes\"];\n\n/**\n * @public\n */\nexport type SigninRedirectArgs = RedirectParams & ExtraSigninRequestArgs;\n\n/**\n * @public\n */\nexport type SigninPopupArgs = PopupWindowParams & ExtraSigninRequestArgs;\n\n/**\n * @public\n */\nexport type SigninSilentArgs = IFrameWindowParams & ExtraSigninRequestArgs;\n\n/**\n * @public\n */\nexport type SigninResourceOwnerCredentialsArgs = ProcessResourceOwnerPasswordCredentialsArgs;\n\n/**\n * @public\n */\nexport type QuerySessionStatusArgs = IFrameWindowParams & ExtraSigninRequestArgs;\n\n/**\n * @public\n */\nexport type SignoutRedirectArgs = RedirectParams & ExtraSignoutRequestArgs;\n\n/**\n * @public\n */\nexport type SignoutPopupArgs = PopupWindowParams & ExtraSignoutRequestArgs;\n\n/**\n * @public\n */\nexport type SignoutSilentArgs = IFrameWindowParams & ExtraSignoutRequestArgs;\n\n/**\n * Provides a higher level API for signing a user in, signing out, managing the user's claims returned from the identity provider,\n * and managing an access token returned from the identity provider (OAuth2/OIDC).\n *\n * @public\n */\nexport class UserManager {\n    /** Get the settings used to configure the `UserManager`. */\n    public readonly settings: UserManagerSettingsStore;\n    protected readonly _logger = new Logger(\"UserManager\");\n\n    protected readonly _client: OidcClient;\n    protected readonly _redirectNavigator: INavigator;\n    protected readonly _popupNavigator: INavigator;\n    protected readonly _iframeNavigator: INavigator;\n    protected readonly _events: UserManagerEvents;\n    protected readonly _silentRenewService: SilentRenewService;\n    protected readonly _sessionMonitor: SessionMonitor | null;\n\n    public constructor(settings: UserManagerSettings, redirectNavigator?: INavigator, popupNavigator?: INavigator, iframeNavigator?: INavigator) {\n        this.settings = new UserManagerSettingsStore(settings);\n\n        this._client = new OidcClient(settings);\n\n        this._redirectNavigator = redirectNavigator ?? new RedirectNavigator(this.settings);\n        this._popupNavigator = popupNavigator ?? new PopupNavigator(this.settings);\n        this._iframeNavigator = iframeNavigator ?? new IFrameNavigator(this.settings);\n\n        this._events = new UserManagerEvents(this.settings);\n        this._silentRenewService = new SilentRenewService(this);\n\n        // order is important for the following properties; these services depend upon the events.\n        if (this.settings.automaticSilentRenew) {\n            this.startSilentRenew();\n        }\n\n        this._sessionMonitor = null;\n        if (this.settings.monitorSession) {\n            this._sessionMonitor = new SessionMonitor(this);\n        }\n    }\n\n    /**\n     * Get object used to register for events raised by the `UserManager`.\n     */\n    public get events(): UserManagerEvents {\n        return this._events;\n    }\n\n    /**\n     * Get object used to access the metadata configuration of the identity provider.\n     */\n    public get metadataService(): MetadataService {\n        return this._client.metadataService;\n    }\n\n    /**\n     * Load the `User` object for the currently authenticated user.\n     *\n     * @param raiseEvent - If `true`, the `UserLoaded` event will be raised. Defaults to false.\n     * @returns A promise\n     */\n    public async getUser(raiseEvent = false): Promise<User | null> {\n        const logger = this._logger.create(\"getUser\");\n        const user = await this._loadUser();\n        if (user) {\n            logger.info(\"user loaded\");\n            await this._events.load(user, raiseEvent);\n            return user;\n        }\n\n        logger.info(\"user not found in storage\");\n        return null;\n    }\n\n    /**\n     * Remove from any storage the currently authenticated user.\n     *\n     * @returns A promise\n     */\n    public async removeUser(): Promise<void> {\n        const logger = this._logger.create(\"removeUser\");\n        await this.storeUser(null);\n        logger.info(\"user removed from storage\");\n        await this._events.unload();\n    }\n\n    /**\n     * Trigger a redirect of the current window to the authorization endpoint.\n     *\n     * @returns A promise\n     *\n     * @throws `Error` In cases of wrong authentication.\n     */\n    public async signinRedirect(args: SigninRedirectArgs = {}): Promise<void> {\n        this._logger.create(\"signinRedirect\");\n        const {\n            redirectMethod,\n            ...requestArgs\n        } = args;\n\n        let dpopJkt: string | undefined;\n        if (this.settings.dpop?.bind_authorization_code) {\n            dpopJkt = await this.generateDPoPJkt(this.settings.dpop);\n        }\n\n        const handle = await this._redirectNavigator.prepare({ redirectMethod });\n        await this._signinStart({\n            request_type: \"si:r\",\n            dpopJkt,\n            ...requestArgs,\n        }, handle);\n    }\n\n    /**\n     * Process the response (callback) from the authorization endpoint.\n     * It is recommended to use {@link UserManager.signinCallback} instead.\n     *\n     * @returns A promise containing the authenticated `User`.\n     *\n     * @see {@link UserManager.signinCallback}\n     */\n    public async signinRedirectCallback(url = window.location.href): Promise<User> {\n        const logger = this._logger.create(\"signinRedirectCallback\");\n        const user = await this._signinEnd(url);\n        if (user.profile && user.profile.sub) {\n            logger.info(\"success, signed in subject\", user.profile.sub);\n        }\n        else {\n            logger.info(\"no subject\");\n        }\n\n        return user;\n    }\n\n    /**\n     * Trigger the signin with user/password.\n     *\n     * @returns A promise containing the authenticated `User`.\n     * @throws {@link ErrorResponse} In cases of wrong authentication.\n     */\n    public async signinResourceOwnerCredentials({\n        username,\n        password,\n        skipUserInfo = false,\n    }: SigninResourceOwnerCredentialsArgs): Promise<User> {\n        const logger = this._logger.create(\"signinResourceOwnerCredential\");\n\n        const signinResponse = await this._client.processResourceOwnerPasswordCredentials({\n            username,\n            password,\n            skipUserInfo,\n            extraTokenParams: this.settings.extraTokenParams,\n        });\n        logger.debug(\"got signin response\");\n\n        const user = await this._buildUser(signinResponse);\n        if (user.profile && user.profile.sub) {\n            logger.info(\"success, signed in subject\", user.profile.sub);\n        } else {\n            logger.info(\"no subject\");\n        }\n        return user;\n    }\n\n    /**\n     * Trigger a request (via a popup window) to the authorization endpoint.\n     *\n     * @returns A promise containing the authenticated `User`.\n     * @throws `Error` In cases of wrong authentication.\n     */\n    public async signinPopup(args: SigninPopupArgs = {}): Promise<User> {\n        const logger = this._logger.create(\"signinPopup\");\n\n        let dpopJkt: string | undefined;\n        if (this.settings.dpop?.bind_authorization_code) {\n            dpopJkt = await this.generateDPoPJkt(this.settings.dpop);\n        }\n\n        const {\n            popupWindowFeatures,\n            popupWindowTarget,\n            popupSignal,\n            ...requestArgs\n        } = args;\n        const url = this.settings.popup_redirect_uri;\n        if (!url) {\n            logger.throw(new Error(\"No popup_redirect_uri configured\"));\n        }\n\n        const handle = await this._popupNavigator.prepare({ popupWindowFeatures, popupWindowTarget, popupSignal });\n        const user = await this._signin({\n            request_type: \"si:p\",\n            redirect_uri: url,\n            display: \"popup\",\n            dpopJkt,\n            ...requestArgs,\n        }, handle);\n        if (user) {\n            if (user.profile && user.profile.sub) {\n                logger.info(\"success, signed in subject\", user.profile.sub);\n            } else {\n                logger.info(\"no subject\");\n            }\n        }\n\n        return user;\n    }\n\n    /**\n     * Notify the opening window of response (callback) from the authorization endpoint.\n     * It is recommended to use {@link UserManager.signinCallback} instead.\n     *\n     * @returns A promise\n     *\n     * @see {@link UserManager.signinCallback}\n     */\n    public async signinPopupCallback(url = window.location.href, keepOpen = false): Promise<void> {\n        const logger = this._logger.create(\"signinPopupCallback\");\n        await this._popupNavigator.callback(url, { keepOpen });\n        logger.info(\"success\");\n    }\n\n    /**\n     * Trigger a silent request (via refresh token or an iframe) to the authorization endpoint.\n     *\n     * @returns A promise that contains the authenticated `User`.\n     */\n    public async signinSilent(args: SigninSilentArgs = {}): Promise<User | null> {\n        const logger = this._logger.create(\"signinSilent\");\n        const {\n            silentRequestTimeoutInSeconds,\n            ...requestArgs\n        } = args;\n        // first determine if we have a refresh token, or need to use iframe\n        let user = await this._loadUser();\n        if (user?.refresh_token) {\n            logger.debug(\"using refresh token\");\n            const state = new RefreshState(user as Required<User>);\n            return await this._useRefreshToken({\n                state,\n                redirect_uri: requestArgs.redirect_uri,\n                resource: requestArgs.resource,\n                extraTokenParams: requestArgs.extraTokenParams,\n                timeoutInSeconds: silentRequestTimeoutInSeconds,\n            });\n        }\n\n        let dpopJkt: string | undefined;\n        if (this.settings.dpop?.bind_authorization_code) {\n            dpopJkt = await this.generateDPoPJkt(this.settings.dpop);\n        }\n\n        const url = this.settings.silent_redirect_uri;\n        if (!url) {\n            logger.throw(new Error(\"No silent_redirect_uri configured\"));\n        }\n\n        let verifySub: string | undefined;\n        if (user && this.settings.validateSubOnSilentRenew) {\n            logger.debug(\"subject prior to silent renew:\", user.profile.sub);\n            verifySub = user.profile.sub;\n        }\n\n        const handle = await this._iframeNavigator.prepare({ silentRequestTimeoutInSeconds });\n        user = await this._signin({\n            request_type: \"si:s\",\n            redirect_uri: url,\n            prompt: \"none\",\n            id_token_hint: this.settings.includeIdTokenInSilentRenew ? user?.id_token : undefined,\n            dpopJkt,\n            ...requestArgs,\n        }, handle, verifySub);\n        if (user) {\n            if (user.profile?.sub) {\n                logger.info(\"success, signed in subject\", user.profile.sub);\n            }\n            else {\n                logger.info(\"no subject\");\n            }\n        }\n\n        return user;\n    }\n\n    protected async _useRefreshToken(args: UseRefreshTokenArgs): Promise<User> {\n        const response = await this._client.useRefreshToken({\n            timeoutInSeconds: this.settings.silentRequestTimeoutInSeconds,\n            ...args,\n        });\n        const user = new User({ ...args.state, ...response });\n\n        await this.storeUser(user);\n        await this._events.load(user);\n        return user;\n    }\n\n    /**\n     *\n     * Notify the parent window of response (callback) from the authorization endpoint.\n     * It is recommended to use {@link UserManager.signinCallback} instead.\n     *\n     * @returns A promise\n     *\n     * @see {@link UserManager.signinCallback}\n     */\n    public async signinSilentCallback(url = window.location.href): Promise<void> {\n        const logger = this._logger.create(\"signinSilentCallback\");\n        await this._iframeNavigator.callback(url);\n        logger.info(\"success\");\n    }\n\n    /**\n     * Process any response (callback) from the authorization endpoint, by dispatching the request_type\n     * and executing one of the following functions:\n     * - {@link UserManager.signinRedirectCallback}\n     * - {@link UserManager.signinPopupCallback}\n     * - {@link UserManager.signinSilentCallback}\n     *\n     * @throws `Error` If request_type is unknown or signin cannot be processed.\n     */\n    public async signinCallback(url = window.location.href): Promise<User | undefined> {\n        const { state } = await this._client.readSigninResponseState(url);\n        switch (state.request_type) {\n            case \"si:r\":\n                return await this.signinRedirectCallback(url);\n            case \"si:p\":\n                await this.signinPopupCallback(url);\n                break;\n            case \"si:s\":\n                await this.signinSilentCallback(url);\n                break;\n            default:\n                throw new Error(\"invalid response_type in state\");\n        }\n        return undefined;\n    }\n\n    /**\n     * Process any response (callback) from the end session endpoint, by dispatching the request_type\n     * and executing one of the following functions:\n     * - {@link UserManager.signoutRedirectCallback}\n     * - {@link UserManager.signoutPopupCallback}\n     * - {@link UserManager.signoutSilentCallback}\n     *\n     * @throws `Error` If request_type is unknown or signout cannot be processed.\n     */\n    public async signoutCallback(url = window.location.href, keepOpen = false): Promise<SignoutResponse | undefined> {\n        const { state } = await this._client.readSignoutResponseState(url);\n        if (!state) {\n            return undefined;\n        }\n\n        switch (state.request_type) {\n            case \"so:r\":\n                return await this.signoutRedirectCallback(url);\n            case \"so:p\":\n                await this.signoutPopupCallback(url, keepOpen);\n                break;\n            case \"so:s\":\n                await this.signoutSilentCallback(url);\n                break;\n            default:\n                throw new Error(\"invalid response_type in state\");\n        }\n        return undefined;\n    }\n\n    /**\n     * Query OP for user's current signin status.\n     *\n     * @returns A promise object with session_state and subject identifier.\n     */\n    public async querySessionStatus(args: QuerySessionStatusArgs = {}): Promise<SessionStatus | null> {\n        const logger = this._logger.create(\"querySessionStatus\");\n        const {\n            silentRequestTimeoutInSeconds,\n            ...requestArgs\n        } = args;\n        const url = this.settings.silent_redirect_uri;\n        if (!url) {\n            logger.throw(new Error(\"No silent_redirect_uri configured\"));\n        }\n\n        const user = await this._loadUser();\n        const handle = await this._iframeNavigator.prepare({ silentRequestTimeoutInSeconds });\n        const navResponse = await this._signinStart({\n            request_type: \"si:s\", // this acts like a signin silent\n            redirect_uri: url,\n            prompt: \"none\",\n            id_token_hint: this.settings.includeIdTokenInSilentRenew ? user?.id_token : undefined,\n            response_type: this.settings.query_status_response_type,\n            scope: \"openid\",\n            skipUserInfo: true,\n            ...requestArgs,\n        }, handle);\n        try {\n            const extraHeaders: Record<string, ExtraHeader> = {};\n            const signinResponse = await this._client.processSigninResponse(navResponse.url, extraHeaders);\n            logger.debug(\"got signin response\");\n\n            if (signinResponse.session_state && signinResponse.profile.sub) {\n                logger.info(\"success for subject\", signinResponse.profile.sub);\n                return {\n                    session_state: signinResponse.session_state,\n                    sub: signinResponse.profile.sub,\n                };\n            }\n\n            logger.info(\"success, user not authenticated\");\n            return null;\n        } catch (err) {\n            if (this.settings.monitorAnonymousSession && err instanceof ErrorResponse) {\n                switch (err.error) {\n                    case \"login_required\":\n                    case \"consent_required\":\n                    case \"interaction_required\":\n                    case \"account_selection_required\":\n                        logger.info(\"success for anonymous user\");\n                        return {\n                            session_state: err.session_state!,\n                        };\n                }\n            }\n            throw err;\n        }\n    }\n\n    protected async _signin(args: CreateSigninRequestArgs, handle: IWindow, verifySub?: string): Promise<User> {\n        const navResponse = await this._signinStart(args, handle);\n        return await this._signinEnd(navResponse.url, verifySub);\n    }\n\n    protected async _signinStart(args: CreateSigninRequestArgs, handle: IWindow): Promise<NavigateResponse> {\n        const logger = this._logger.create(\"_signinStart\");\n\n        try {\n            const signinRequest = await this._client.createSigninRequest(args);\n            logger.debug(\"got signin request\");\n\n            return await handle.navigate({\n                url: signinRequest.url,\n                state: signinRequest.state.id,\n                response_mode: signinRequest.state.response_mode,\n                scriptOrigin: this.settings.iframeScriptOrigin,\n            });\n        } catch (err) {\n            logger.debug(\"error after preparing navigator, closing navigator window\");\n            handle.close();\n            throw err;\n        }\n    }\n\n    protected async _signinEnd(url: string, verifySub?: string): Promise<User> {\n        const logger = this._logger.create(\"_signinEnd\");\n        const extraHeaders: Record<string, ExtraHeader> = {};\n        const signinResponse = await this._client.processSigninResponse(url, extraHeaders);\n        logger.debug(\"got signin response\");\n\n        const user = await this._buildUser(signinResponse, verifySub);\n        return user;\n    }\n\n    protected async _buildUser(signinResponse: SigninResponse, verifySub?: string) {\n        const logger = this._logger.create(\"_buildUser\");\n        const user = new User(signinResponse);\n        if (verifySub) {\n            if (verifySub !== user.profile.sub) {\n                logger.debug(\"current user does not match user returned from signin. sub from signin:\", user.profile.sub);\n                throw new ErrorResponse({ ...signinResponse, error: \"login_required\" });\n            }\n            logger.debug(\"current user matches user returned from signin\");\n        }\n\n        await this.storeUser(user);\n        logger.debug(\"user stored\");\n        await this._events.load(user);\n\n        return user;\n    }\n\n    /**\n     * Trigger a redirect of the current window to the end session endpoint.\n     *\n     * @returns A promise\n     */\n    public async signoutRedirect(args: SignoutRedirectArgs = {}): Promise<void> {\n        const logger = this._logger.create(\"signoutRedirect\");\n        const {\n            redirectMethod,\n            ...requestArgs\n        } = args;\n        const handle = await this._redirectNavigator.prepare({ redirectMethod });\n        await this._signoutStart({\n            request_type: \"so:r\",\n            post_logout_redirect_uri: this.settings.post_logout_redirect_uri,\n            ...requestArgs,\n        }, handle);\n        logger.info(\"success\");\n    }\n\n    /**\n     * Process response (callback) from the end session endpoint.\n     * It is recommended to use {@link UserManager.signoutCallback} instead.\n     *\n     * @returns A promise containing signout response\n     *\n     * @see {@link UserManager.signoutCallback}\n     */\n    public async signoutRedirectCallback(url = window.location.href): Promise<SignoutResponse> {\n        const logger = this._logger.create(\"signoutRedirectCallback\");\n        const response = await this._signoutEnd(url);\n        logger.info(\"success\");\n        return response;\n    }\n\n    /**\n     * Trigger a redirect of a popup window to the end session endpoint.\n     *\n     * @returns A promise\n     */\n    public async signoutPopup(args: SignoutPopupArgs = {}): Promise<void> {\n        const logger = this._logger.create(\"signoutPopup\");\n        const {\n            popupWindowFeatures,\n            popupWindowTarget,\n            popupSignal,\n            ...requestArgs\n        } = args;\n        const url = this.settings.popup_post_logout_redirect_uri;\n\n        const handle = await this._popupNavigator.prepare({ popupWindowFeatures, popupWindowTarget, popupSignal });\n        await this._signout({\n            request_type: \"so:p\",\n            post_logout_redirect_uri: url,\n            // we're putting a dummy entry in here because we\n            // need a unique id from the state for notification\n            // to the parent window, which is necessary if we\n            // plan to return back to the client after signout\n            // and so we can close the popup after signout\n            state: url == null ? undefined : {},\n            ...requestArgs,\n        }, handle);\n        logger.info(\"success\");\n    }\n\n    /**\n     * Process response (callback) from the end session endpoint from a popup window.\n     * It is recommended to use {@link UserManager.signoutCallback} instead.\n     *\n     * @returns A promise\n     *\n     * @see {@link UserManager.signoutCallback}\n     */\n    public async signoutPopupCallback(url = window.location.href, keepOpen = false): Promise<void> {\n        const logger = this._logger.create(\"signoutPopupCallback\");\n        await this._popupNavigator.callback(url, { keepOpen });\n        logger.info(\"success\");\n    }\n\n    protected async _signout(args: CreateSignoutRequestArgs, handle: IWindow): Promise<SignoutResponse> {\n        const navResponse = await this._signoutStart(args, handle);\n        return await this._signoutEnd(navResponse.url);\n    }\n\n    protected async _signoutStart(args: CreateSignoutRequestArgs = {}, handle: IWindow): Promise<NavigateResponse> {\n        const logger = this._logger.create(\"_signoutStart\");\n\n        try {\n            const user = await this._loadUser();\n            logger.debug(\"loaded current user from storage\");\n\n            if (this.settings.revokeTokensOnSignout) {\n                await this._revokeInternal(user);\n            }\n\n            const id_token = args.id_token_hint || user && user.id_token;\n            if (id_token) {\n                logger.debug(\"setting id_token_hint in signout request\");\n                args.id_token_hint = id_token;\n            }\n\n            await this.removeUser();\n            logger.debug(\"user removed, creating signout request\");\n\n            const signoutRequest = await this._client.createSignoutRequest(args);\n            logger.debug(\"got signout request\");\n\n            return await handle.navigate({\n                url: signoutRequest.url,\n                state: signoutRequest.state?.id,\n                scriptOrigin: this.settings.iframeScriptOrigin,\n            });\n        } catch (err) {\n            logger.debug(\"error after preparing navigator, closing navigator window\");\n            handle.close();\n            throw err;\n        }\n    }\n\n    protected async _signoutEnd(url: string): Promise<SignoutResponse> {\n        const logger = this._logger.create(\"_signoutEnd\");\n        const signoutResponse = await this._client.processSignoutResponse(url);\n        logger.debug(\"got signout response\");\n\n        return signoutResponse;\n    }\n\n    /**\n     * Trigger a silent request (via an iframe) to the end session endpoint.\n     *\n     * @returns A promise\n     */\n    public async signoutSilent(args: SignoutSilentArgs = {}): Promise<void> {\n        const logger = this._logger.create(\"signoutSilent\");\n        const {\n            silentRequestTimeoutInSeconds,\n            ...requestArgs\n        } = args;\n\n        const id_token_hint = this.settings.includeIdTokenInSilentSignout\n            ? (await this._loadUser())?.id_token\n            : undefined;\n\n        const url = this.settings.popup_post_logout_redirect_uri;\n        const handle = await this._iframeNavigator.prepare({ silentRequestTimeoutInSeconds });\n        await this._signout({\n            request_type: \"so:s\",\n            post_logout_redirect_uri: url,\n            id_token_hint: id_token_hint,\n            ...requestArgs,\n        }, handle);\n\n        logger.info(\"success\");\n    }\n\n    /**\n     * Notify the parent window of response (callback) from the end session endpoint.\n     * It is recommended to use {@link UserManager.signoutCallback} instead.\n     *\n     * @returns A promise\n     *\n     * @see {@link UserManager.signoutCallback}\n     */\n    public async signoutSilentCallback(url = window.location.href): Promise<void> {\n        const logger = this._logger.create(\"signoutSilentCallback\");\n        await this._iframeNavigator.callback(url);\n        logger.info(\"success\");\n    }\n\n    public async revokeTokens(types?: RevokeTokensTypes): Promise<void> {\n        const user = await this._loadUser();\n        await this._revokeInternal(user, types);\n    }\n\n    protected async _revokeInternal(user: User | null, types = this.settings.revokeTokenTypes): Promise<void> {\n        const logger = this._logger.create(\"_revokeInternal\");\n        if (!user) return;\n\n        const typesPresent = types.filter(type => typeof user[type] === \"string\");\n\n        if (!typesPresent.length) {\n            logger.debug(\"no need to revoke due to no token(s)\");\n            return;\n        }\n\n        // don't Promise.all, order matters\n        for (const type of typesPresent) {\n            await this._client.revokeToken(\n                user[type]!,\n                type,\n            );\n            logger.info(`${type} revoked successfully`);\n            if (type !== \"access_token\") {\n                user[type] = null as never;\n            }\n        }\n\n        await this.storeUser(user);\n        logger.debug(\"user stored\");\n        await this._events.load(user);\n    }\n\n    /**\n     * Enables silent renew for the `UserManager`.\n     */\n    public startSilentRenew(): void {\n        this._logger.create(\"startSilentRenew\");\n        void this._silentRenewService.start();\n    }\n\n    /**\n     * Disables silent renew for the `UserManager`.\n     */\n    public stopSilentRenew(): void {\n        this._silentRenewService.stop();\n    }\n\n    protected get _userStoreKey(): string {\n        return `user:${this.settings.authority}:${this.settings.client_id}`;\n    }\n\n    protected async _loadUser(): Promise<User | null> {\n        const logger = this._logger.create(\"_loadUser\");\n        const storageString = await this.settings.userStore.get(this._userStoreKey);\n        if (storageString) {\n            logger.debug(\"user storageString loaded\");\n            return User.fromStorageString(storageString);\n        }\n\n        logger.debug(\"no user storageString\");\n        return null;\n    }\n\n    public async storeUser(user: User | null): Promise<void> {\n        const logger = this._logger.create(\"storeUser\");\n        if (user) {\n            logger.debug(\"storing user\");\n            const storageString = user.toStorageString();\n            await this.settings.userStore.set(this._userStoreKey, storageString);\n        } else {\n            this._logger.debug(\"removing user\");\n            await this.settings.userStore.remove(this._userStoreKey);\n            if (this.settings.dpop) {\n                await this.settings.dpop.store.remove(this.settings.client_id);\n            }\n        }\n    }\n\n    /**\n     * Removes stale state entries in storage for incomplete authorize requests.\n     */\n    public async clearStaleState(): Promise<void> {\n        await this._client.clearStaleState();\n    }\n\n    /**\n     * Dynamically generates a DPoP proof for a given user, URL and optional Http method.\n     * This method is useful when you need to make a request to a resource server\n     * with fetch or similar, and you need to include a DPoP proof in a DPoP header.\n     * @param url - The URL to generate the DPoP proof for\n     * @param user - The user to generate the DPoP proof for\n     * @param httpMethod - Optional, defaults to \"GET\"\n     * @param nonce - Optional nonce provided by the resource server\n     *\n     * @returns A promise containing the DPoP proof or undefined if DPoP is not enabled/no user is found.\n     */\n    public async dpopProof(url: string, user: User, httpMethod?: string, nonce?: string): Promise<string | undefined> {\n        const dpopState = await this.settings.dpop?.store?.get(this.settings.client_id);\n        if (dpopState) {\n            return await CryptoUtils.generateDPoPProof({\n                url,\n                accessToken: user?.access_token,\n                httpMethod: httpMethod,\n                keyPair: dpopState.keys,\n                nonce,\n            });\n        }\n        return undefined;\n    }\n\n    async generateDPoPJkt(dpopSettings: DPoPSettings): Promise<string | undefined> {\n        let dpopState = await dpopSettings.store.get(this.settings.client_id);\n        if (!dpopState) {\n            const dpopKeys = await CryptoUtils.generateDPoPKeys();\n            dpopState = new DPoPState(dpopKeys);\n            await dpopSettings.store.set(this.settings.client_id, dpopState);\n        }\n        return await CryptoUtils.generateDPoPJkt(dpopState.keys);\n    }\n}\n", "{\n  \"name\": \"oidc-client-ts\",\n  \"version\": \"3.3.0\",\n  \"description\": \"OpenID Connect (OIDC) & OAuth2 client library\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/authts/oidc-client-ts.git\"\n  },\n  \"homepage\": \"https://github.com/authts/oidc-client-ts#readme\",\n  \"license\": \"Apache-2.0\",\n  \"main\": \"dist/umd/oidc-client-ts.js\",\n  \"types\": \"dist/types/oidc-client-ts.d.ts\",\n  \"exports\": {\n    \".\": {\n      \"types\": \"./dist/types/oidc-client-ts.d.ts\",\n      \"import\": \"./dist/esm/oidc-client-ts.js\",\n      \"require\": \"./dist/umd/oidc-client-ts.js\"\n    },\n    \"./package.json\": \"./package.json\"\n  },\n  \"files\": [\n    \"dist\"\n  ],\n  \"keywords\": [\n    \"authentication\",\n    \"oauth2\",\n    \"oidc\",\n    \"openid\",\n    \"OpenID Connect\"\n  ],\n  \"scripts\": {\n    \"build\": \"node scripts/build.js && npm run build-types\",\n    \"build-types\": \"tsc -p tsconfig.build.json && api-extractor run\",\n    \"clean\": \"git clean -fdX dist lib *.tsbuildinfo\",\n    \"prepack\": \"npm run build\",\n    \"test\": \"tsc && jest\",\n    \"typedoc\": \"typedoc\",\n    \"lint\": \"eslint --max-warnings=0 --cache .\",\n    \"prepare\": \"husky\"\n  },\n  \"dependencies\": {\n    \"jwt-decode\": \"^4.0.0\"\n  },\n  \"devDependencies\": {\n    \"@eslint/eslintrc\": \"^3.2.0\",\n    \"@eslint/js\": \"^9.18.0\",\n    \"@microsoft/api-extractor\": \"^7.49.1\",\n    \"@stylistic/eslint-plugin\": \"^2.13.0\",\n    \"@testing-library/jest-dom\": \"^6.6.3\",\n    \"@types/jest\": \"^29.5.14\",\n    \"@types/node\": \"^22.10.1\",\n    \"@typescript-eslint/eslint-plugin\": \"^8.20.0\",\n    \"@typescript-eslint/parser\": \"^8.20.0\",\n    \"esbuild\": \"^0.25.0\",\n    \"eslint\": \"^9.18.0\",\n    \"eslint-plugin-testing-library\": \"^7.1.1\",\n    \"fake-indexeddb\": \"^6.0.0\",\n    \"globals\": \"^16.0.0\",\n    \"http-proxy-middleware\": \"^3.0.3\",\n    \"husky\": \"^9.1.7\",\n    \"jest\": \"^29.7.0\",\n    \"jest-environment-jsdom\": \"^29.7.0\",\n    \"jest-mock\": \"^29.7.0\",\n    \"jose\": \"^5.9.6\",\n    \"lint-staged\": \"^16.1.0\",\n    \"ts-jest\": \"^29.2.5\",\n    \"typedoc\": \"^0.28.0\",\n    \"typescript\": \"~5.8.2\",\n    \"yn\": \"^5.0.0\"\n  },\n  \"engines\": {\n    \"node\": \">=18\"\n  },\n  \"lint-staged\": {\n    \"*.{js,jsx,ts,tsx}\": \"eslint --cache --fix\"\n  }\n}\n", "// @ts-expect-error avoid enabling resolveJsonModule to keep build process simple\nimport { version } from \"../package.json\";\n\n/**\n * @public\n */\nexport const Version: string = version;\n", "import { DPoPState, type DPoPStore } from \"./DPoPStore\";\n\n/**\n * Provides a default implementation of the DPoP store using IndexedDB.\n *\n * @public\n */\nexport class IndexedDbDPoPStore implements DPoPStore {\n    readonly _dbName: string = \"oidc\";\n    readonly _storeName: string = \"dpop\";\n\n    public async set(key: string, value: DPoPState): Promise<void> {\n        const store = await this.createStore(this._dbName, this._storeName);\n        await store(\"readwrite\", (str: IDBObjectStore) => {\n            str.put(value, key);\n            return this.promisifyRequest(str.transaction);\n        });\n    }\n\n    public async get(key: string): Promise<DPoPState> {\n        const store = await this.createStore(this._dbName, this._storeName);\n        return await store(\"readonly\", (str) => {\n            return this.promisifyRequest(str.get(key));\n        }) as DPoPState;\n    }\n\n    public async remove(key: string): Promise<DPoPState> {\n        const item = await this.get(key);\n        const store = await this.createStore(this._dbName, this._storeName);\n        await store(\"readwrite\", (str) => {\n            return this.promisifyRequest(str.delete(key));\n        });\n        return item;\n    }\n\n    public async getAllKeys(): Promise<string[]> {\n        const store = await this.createStore(this._dbName, this._storeName);\n        return await store(\"readonly\", (str) => {\n            return this.promisifyRequest(str.getAllKeys());\n        }) as string[];\n    }\n\n    promisifyRequest<T = undefined>(\n        request: IDBRequest<T> | IDBTransaction): Promise<T> {\n        return new Promise<T>((resolve, reject) => {\n            (request as IDBTransaction).oncomplete = (request as IDBRequest<T>).onsuccess = () => resolve((request as IDBRequest<T>).result);\n            (request as IDBTransaction).onabort = (request as IDBRequest<T>).onerror = () => reject((request as IDBRequest<T>).error as Error);\n        });\n    }\n\n    async createStore<T>(\n        dbName: string,\n        storeName: string,\n    ): Promise<(txMode: IDBTransactionMode, callback: (store: IDBObjectStore) => T | PromiseLike<T>) => Promise<T>> {\n        const request = indexedDB.open(dbName);\n        request.onupgradeneeded = () => request.result.createObjectStore(storeName);\n        const db = await this.promisifyRequest<IDBDatabase>(request);\n\n        return async (\n            txMode: IDBTransactionMode,\n            callback: (store: IDBObjectStore) => T | PromiseLike<T>,\n        ) => {\n            const tx = db.transaction(storeName, txMode);\n            const store = tx.objectStore(storeName);\n            return await callback(store);\n        };\n    }\n}\n", "import process from 'node:process';\nimport {Buffer} from 'node:buffer';\nimport path from 'node:path';\nimport {fileURLToPath} from 'node:url';\nimport {promisify} from 'node:util';\nimport childProcess from 'node:child_process';\nimport fs, {constants as fsConstants} from 'node:fs/promises';\nimport {isWsl, powerShellPath} from 'wsl-utils';\nimport defineLazyProperty from 'define-lazy-prop';\nimport defaultBrowser from 'default-browser';\nimport isInsideContainer from 'is-inside-container';\n\nconst execFile = promisify(childProcess.execFile);\n\n// Path to included `xdg-open`.\nconst __dirname = path.dirname(fileURLToPath(import.meta.url));\nconst localXdgOpenPath = path.join(__dirname, 'xdg-open');\n\nconst {platform, arch} = process;\n\n/**\nGet the default browser name in Windows from WSL.\n\n@returns {Promise<string>} Browser name.\n*/\nasync function getWindowsDefaultBrowserFromWsl() {\n\tconst powershellPath = await powerShellPath();\n\tconst rawCommand = String.raw`(Get-ItemProperty -Path \"HKCU:\\Software\\Microsoft\\Windows\\Shell\\Associations\\UrlAssociations\\http\\UserChoice\").ProgId`;\n\tconst encodedCommand = Buffer.from(rawCommand, 'utf16le').toString('base64');\n\n\tconst {stdout} = await execFile(\n\t\tpowershellPath,\n\t\t[\n\t\t\t'-NoProfile',\n\t\t\t'-NonInteractive',\n\t\t\t'-ExecutionPolicy',\n\t\t\t'Bypass',\n\t\t\t'-EncodedCommand',\n\t\t\tencodedCommand,\n\t\t],\n\t\t{encoding: 'utf8'},\n\t);\n\n\tconst progId = stdout.trim();\n\n\t// Map ProgId to browser IDs\n\tconst browserMap = {\n\t\tChromeHTML: 'com.google.chrome',\n\t\tBraveHTML: 'com.brave.Browser',\n\t\tMSEdgeHTM: 'com.microsoft.edge',\n\t\tFirefoxURL: 'org.mozilla.firefox',\n\t};\n\n\treturn browserMap[progId] ? {id: browserMap[progId]} : {};\n}\n\nconst pTryEach = async (array, mapper) => {\n\tlet latestError;\n\n\tfor (const item of array) {\n\t\ttry {\n\t\t\treturn await mapper(item); // eslint-disable-line no-await-in-loop\n\t\t} catch (error) {\n\t\t\tlatestError = error;\n\t\t}\n\t}\n\n\tthrow latestError;\n};\n\n// eslint-disable-next-line complexity\nconst baseOpen = async options => {\n\toptions = {\n\t\twait: false,\n\t\tbackground: false,\n\t\tnewInstance: false,\n\t\tallowNonzeroExitCode: false,\n\t\t...options,\n\t};\n\n\tif (Array.isArray(options.app)) {\n\t\treturn pTryEach(options.app, singleApp => baseOpen({\n\t\t\t...options,\n\t\t\tapp: singleApp,\n\t\t}));\n\t}\n\n\tlet {name: app, arguments: appArguments = []} = options.app ?? {};\n\tappArguments = [...appArguments];\n\n\tif (Array.isArray(app)) {\n\t\treturn pTryEach(app, appName => baseOpen({\n\t\t\t...options,\n\t\t\tapp: {\n\t\t\t\tname: appName,\n\t\t\t\targuments: appArguments,\n\t\t\t},\n\t\t}));\n\t}\n\n\tif (app === 'browser' || app === 'browserPrivate') {\n\t\t// IDs from default-browser for macOS and windows are the same\n\t\tconst ids = {\n\t\t\t'com.google.chrome': 'chrome',\n\t\t\t'google-chrome.desktop': 'chrome',\n\t\t\t'com.brave.Browser': 'brave',\n\t\t\t'org.mozilla.firefox': 'firefox',\n\t\t\t'firefox.desktop': 'firefox',\n\t\t\t'com.microsoft.msedge': 'edge',\n\t\t\t'com.microsoft.edge': 'edge',\n\t\t\t'com.microsoft.edgemac': 'edge',\n\t\t\t'microsoft-edge.desktop': 'edge',\n\t\t};\n\n\t\t// Incognito flags for each browser in `apps`.\n\t\tconst flags = {\n\t\t\tchrome: '--incognito',\n\t\t\tbrave: '--incognito',\n\t\t\tfirefox: '--private-window',\n\t\t\tedge: '--inPrivate',\n\t\t};\n\n\t\tconst browser = isWsl ? await getWindowsDefaultBrowserFromWsl() : await defaultBrowser();\n\t\tif (browser.id in ids) {\n\t\t\tconst browserName = ids[browser.id];\n\n\t\t\tif (app === 'browserPrivate') {\n\t\t\t\tappArguments.push(flags[browserName]);\n\t\t\t}\n\n\t\t\treturn baseOpen({\n\t\t\t\t...options,\n\t\t\t\tapp: {\n\t\t\t\t\tname: apps[browserName],\n\t\t\t\t\targuments: appArguments,\n\t\t\t\t},\n\t\t\t});\n\t\t}\n\n\t\tthrow new Error(`${browser.name} is not supported as a default browser`);\n\t}\n\n\tlet command;\n\tconst cliArguments = [];\n\tconst childProcessOptions = {};\n\n\tif (platform === 'darwin') {\n\t\tcommand = 'open';\n\n\t\tif (options.wait) {\n\t\t\tcliArguments.push('--wait-apps');\n\t\t}\n\n\t\tif (options.background) {\n\t\t\tcliArguments.push('--background');\n\t\t}\n\n\t\tif (options.newInstance) {\n\t\t\tcliArguments.push('--new');\n\t\t}\n\n\t\tif (app) {\n\t\t\tcliArguments.push('-a', app);\n\t\t}\n\t} else if (platform === 'win32' || (isWsl && !isInsideContainer() && !app)) {\n\t\tcommand = await powerShellPath();\n\n\t\tcliArguments.push(\n\t\t\t'-NoProfile',\n\t\t\t'-NonInteractive',\n\t\t\t'-ExecutionPolicy',\n\t\t\t'Bypass',\n\t\t\t'-EncodedCommand',\n\t\t);\n\n\t\tif (!isWsl) {\n\t\t\tchildProcessOptions.windowsVerbatimArguments = true;\n\t\t}\n\n\t\tconst encodedArguments = ['Start'];\n\n\t\tif (options.wait) {\n\t\t\tencodedArguments.push('-Wait');\n\t\t}\n\n\t\tif (app) {\n\t\t\t// Double quote with double quotes to ensure the inner quotes are passed through.\n\t\t\t// Inner quotes are delimited for PowerShell interpretation with backticks.\n\t\t\tencodedArguments.push(`\"\\`\"${app}\\`\"\"`);\n\t\t\tif (options.target) {\n\t\t\t\tappArguments.push(options.target);\n\t\t\t}\n\t\t} else if (options.target) {\n\t\t\tencodedArguments.push(`\"${options.target}\"`);\n\t\t}\n\n\t\tif (appArguments.length > 0) {\n\t\t\tappArguments = appArguments.map(argument => `\"\\`\"${argument}\\`\"\"`);\n\t\t\tencodedArguments.push('-ArgumentList', appArguments.join(','));\n\t\t}\n\n\t\t// Using Base64-encoded command, accepted by PowerShell, to allow special characters.\n\t\toptions.target = Buffer.from(encodedArguments.join(' '), 'utf16le').toString('base64');\n\t} else {\n\t\tif (app) {\n\t\t\tcommand = app;\n\t\t} else {\n\t\t\t// When bundled by Webpack, there's no actual package file path and no local `xdg-open`.\n\t\t\tconst isBundled = !__dirname || __dirname === '/';\n\n\t\t\t// Check if local `xdg-open` exists and is executable.\n\t\t\tlet exeLocalXdgOpen = false;\n\t\t\ttry {\n\t\t\t\tawait fs.access(localXdgOpenPath, fsConstants.X_OK);\n\t\t\t\texeLocalXdgOpen = true;\n\t\t\t} catch {}\n\n\t\t\tconst useSystemXdgOpen = process.versions.electron\n\t\t\t\t?? (platform === 'android' || isBundled || !exeLocalXdgOpen);\n\t\t\tcommand = useSystemXdgOpen ? 'xdg-open' : localXdgOpenPath;\n\t\t}\n\n\t\tif (appArguments.length > 0) {\n\t\t\tcliArguments.push(...appArguments);\n\t\t}\n\n\t\tif (!options.wait) {\n\t\t\t// `xdg-open` will block the process unless stdio is ignored\n\t\t\t// and it's detached from the parent even if it's unref'd.\n\t\t\tchildProcessOptions.stdio = 'ignore';\n\t\t\tchildProcessOptions.detached = true;\n\t\t}\n\t}\n\n\tif (platform === 'darwin' && appArguments.length > 0) {\n\t\tcliArguments.push('--args', ...appArguments);\n\t}\n\n\t// This has to come after `--args`.\n\tif (options.target) {\n\t\tcliArguments.push(options.target);\n\t}\n\n\tconst subprocess = childProcess.spawn(command, cliArguments, childProcessOptions);\n\n\tif (options.wait) {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tsubprocess.once('error', reject);\n\n\t\t\tsubprocess.once('close', exitCode => {\n\t\t\t\tif (!options.allowNonzeroExitCode && exitCode > 0) {\n\t\t\t\t\treject(new Error(`Exited with code ${exitCode}`));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tresolve(subprocess);\n\t\t\t});\n\t\t});\n\t}\n\n\tsubprocess.unref();\n\n\treturn subprocess;\n};\n\nconst open = (target, options) => {\n\tif (typeof target !== 'string') {\n\t\tthrow new TypeError('Expected a `target`');\n\t}\n\n\treturn baseOpen({\n\t\t...options,\n\t\ttarget,\n\t});\n};\n\nexport const openApp = (name, options) => {\n\tif (typeof name !== 'string' && !Array.isArray(name)) {\n\t\tthrow new TypeError('Expected a valid `name`');\n\t}\n\n\tconst {arguments: appArguments = []} = options ?? {};\n\tif (appArguments !== undefined && appArguments !== null && !Array.isArray(appArguments)) {\n\t\tthrow new TypeError('Expected `appArguments` as Array type');\n\t}\n\n\treturn baseOpen({\n\t\t...options,\n\t\tapp: {\n\t\t\tname,\n\t\t\targuments: appArguments,\n\t\t},\n\t});\n};\n\nfunction detectArchBinary(binary) {\n\tif (typeof binary === 'string' || Array.isArray(binary)) {\n\t\treturn binary;\n\t}\n\n\tconst {[arch]: archBinary} = binary;\n\n\tif (!archBinary) {\n\t\tthrow new Error(`${arch} is not supported`);\n\t}\n\n\treturn archBinary;\n}\n\nfunction detectPlatformBinary({[platform]: platformBinary}, {wsl}) {\n\tif (wsl && isWsl) {\n\t\treturn detectArchBinary(wsl);\n\t}\n\n\tif (!platformBinary) {\n\t\tthrow new Error(`${platform} is not supported`);\n\t}\n\n\treturn detectArchBinary(platformBinary);\n}\n\nexport const apps = {};\n\ndefineLazyProperty(apps, 'chrome', () => detectPlatformBinary({\n\tdarwin: 'google chrome',\n\twin32: 'chrome',\n\tlinux: ['google-chrome', 'google-chrome-stable', 'chromium'],\n}, {\n\twsl: {\n\t\tia32: '/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe',\n\t\tx64: ['/mnt/c/Program Files/Google/Chrome/Application/chrome.exe', '/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe'],\n\t},\n}));\n\ndefineLazyProperty(apps, 'brave', () => detectPlatformBinary({\n\tdarwin: 'brave browser',\n\twin32: 'brave',\n\tlinux: ['brave-browser', 'brave'],\n}, {\n\twsl: {\n\t\tia32: '/mnt/c/Program Files (x86)/BraveSoftware/Brave-Browser/Application/brave.exe',\n\t\tx64: ['/mnt/c/Program Files/BraveSoftware/Brave-Browser/Application/brave.exe', '/mnt/c/Program Files (x86)/BraveSoftware/Brave-Browser/Application/brave.exe'],\n\t},\n}));\n\ndefineLazyProperty(apps, 'firefox', () => detectPlatformBinary({\n\tdarwin: 'firefox',\n\twin32: String.raw`C:\\Program Files\\Mozilla Firefox\\firefox.exe`,\n\tlinux: 'firefox',\n}, {\n\twsl: '/mnt/c/Program Files/Mozilla Firefox/firefox.exe',\n}));\n\ndefineLazyProperty(apps, 'edge', () => detectPlatformBinary({\n\tdarwin: 'microsoft edge',\n\twin32: 'msedge',\n\tlinux: ['microsoft-edge', 'microsoft-edge-dev'],\n}, {\n\twsl: '/mnt/c/Program Files (x86)/Microsoft/Edge/Application/msedge.exe',\n}));\n\ndefineLazyProperty(apps, 'browser', () => 'browser');\n\ndefineLazyProperty(apps, 'browserPrivate', () => 'browserPrivate');\n\nexport default open;\n", "import process from 'node:process';\nimport fs, {constants as fsConstants} from 'node:fs/promises';\nimport isWsl from 'is-wsl';\n\nexport const wslDrivesMountPoint = (() => {\n\t// Default value for \"root\" param\n\t// according to https://docs.microsoft.com/en-us/windows/wsl/wsl-config\n\tconst defaultMountPoint = '/mnt/';\n\n\tlet mountPoint;\n\n\treturn async function () {\n\t\tif (mountPoint) {\n\t\t\t// Return memoized mount point value\n\t\t\treturn mountPoint;\n\t\t}\n\n\t\tconst configFilePath = '/etc/wsl.conf';\n\n\t\tlet isConfigFileExists = false;\n\t\ttry {\n\t\t\tawait fs.access(configFilePath, fsConstants.F_OK);\n\t\t\tisConfigFileExists = true;\n\t\t} catch {}\n\n\t\tif (!isConfigFileExists) {\n\t\t\treturn defaultMountPoint;\n\t\t}\n\n\t\tconst configContent = await fs.readFile(configFilePath, {encoding: 'utf8'});\n\t\tconst configMountPoint = /(?<!#.*)root\\s*=\\s*(?<mountPoint>.*)/g.exec(configContent);\n\n\t\tif (!configMountPoint) {\n\t\t\treturn defaultMountPoint;\n\t\t}\n\n\t\tmountPoint = configMountPoint.groups.mountPoint.trim();\n\t\tmountPoint = mountPoint.endsWith('/') ? mountPoint : `${mountPoint}/`;\n\n\t\treturn mountPoint;\n\t};\n})();\n\nexport const powerShellPathFromWsl = async () => {\n\tconst mountPoint = await wslDrivesMountPoint();\n\treturn `${mountPoint}c/Windows/System32/WindowsPowerShell/v1.0/powershell.exe`;\n};\n\nexport const powerShellPath = async () => {\n\tif (isWsl) {\n\t\treturn powerShellPathFromWsl();\n\t}\n\n\treturn `${process.env.SYSTEMROOT || process.env.windir || String.raw`C:\\Windows`}\\\\System32\\\\WindowsPowerShell\\\\v1.0\\\\powershell.exe`;\n};\n\nexport {default as isWsl} from 'is-wsl';\n", "import process from 'node:process';\nimport os from 'node:os';\nimport fs from 'node:fs';\nimport isInsideContainer from 'is-inside-container';\n\nconst isWsl = () => {\n\tif (process.platform !== 'linux') {\n\t\treturn false;\n\t}\n\n\tif (os.release().toLowerCase().includes('microsoft')) {\n\t\tif (isInsideContainer()) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\ttry {\n\t\treturn fs.readFileSync('/proc/version', 'utf8').toLowerCase().includes('microsoft')\n\t\t\t? !isInsideContainer() : false;\n\t} catch {\n\t\treturn false;\n\t}\n};\n\nexport default process.env.__IS_WSL_TEST__ ? isWsl : isWsl();\n", "import fs from 'node:fs';\nimport isDocker from 'is-docker';\n\nlet cachedResult;\n\n// Podman detection\nconst hasContainerEnv = () => {\n\ttry {\n\t\tfs.statSync('/run/.containerenv');\n\t\treturn true;\n\t} catch {\n\t\treturn false;\n\t}\n};\n\nexport default function isInsideContainer() {\n\t// TODO: Use `??=` when targeting Node.js 16.\n\tif (cachedResult === undefined) {\n\t\tcachedResult = hasContainerEnv() || isDocker();\n\t}\n\n\treturn cachedResult;\n}\n", "import fs from 'node:fs';\n\nlet isDockerCached;\n\nfunction hasDockerEnv() {\n\ttry {\n\t\tfs.statSync('/.dockerenv');\n\t\treturn true;\n\t} catch {\n\t\treturn false;\n\t}\n}\n\nfunction hasDockerCGroup() {\n\ttry {\n\t\treturn fs.readFileSync('/proc/self/cgroup', 'utf8').includes('docker');\n\t} catch {\n\t\treturn false;\n\t}\n}\n\nexport default function isDocker() {\n\t// TODO: Use `??=` when targeting Node.js 16.\n\tif (isDockerCached === undefined) {\n\t\tisDockerCached = hasDockerEnv() || hasDockerCGroup();\n\t}\n\n\treturn isDockerCached;\n}\n", "export default function defineLazyProperty(object, propertyName, valueGetter) {\n\tconst define = value => Object.defineProperty(object, propertyName, {value, enumerable: true, writable: true});\n\n\tObject.defineProperty(object, propertyName, {\n\t\tconfigurable: true,\n\t\tenumerable: true,\n\t\tget() {\n\t\t\tconst result = valueGetter();\n\t\t\tdefine(result);\n\t\t\treturn result;\n\t\t},\n\t\tset(value) {\n\t\t\tdefine(value);\n\t\t}\n\t});\n\n\treturn object;\n}\n", "import {promisify} from 'node:util';\nimport process from 'node:process';\nimport {execFile} from 'node:child_process';\nimport defaultBrowserId from 'default-browser-id';\nimport bundleName from 'bundle-name';\nimport windows from './windows.js';\n\nconst execFileAsync = promisify(execFile);\n\n// Inlined: https://github.com/sindresorhus/titleize/blob/main/index.js\nconst titleize = string => string.toLowerCase().replaceAll(/(?:^|\\s|-)\\S/g, x => x.toUpperCase());\n\nexport default async function defaultBrowser() {\n\tif (process.platform === 'darwin') {\n\t\tconst id = await defaultBrowserId();\n\t\tconst name = await bundleName(id);\n\t\treturn {name, id};\n\t}\n\n\tif (process.platform === 'linux') {\n\t\tconst {stdout} = await execFileAsync('xdg-mime', ['query', 'default', 'x-scheme-handler/http']);\n\t\tconst id = stdout.trim();\n\t\tconst name = titleize(id.replace(/.desktop$/, '').replace('-', ' '));\n\t\treturn {name, id};\n\t}\n\n\tif (process.platform === 'win32') {\n\t\treturn windows();\n\t}\n\n\tthrow new Error('Only macOS, Linux, and Windows are supported');\n}\n", "import {promisify} from 'node:util';\nimport process from 'node:process';\nimport {execFile} from 'node:child_process';\n\nconst execFileAsync = promisify(execFile);\n\nexport default async function defaultBrowserId() {\n\tif (process.platform !== 'darwin') {\n\t\tthrow new Error('macOS only');\n\t}\n\n\tconst {stdout} = await execFileAsync('defaults', ['read', 'com.apple.LaunchServices/com.apple.launchservices.secure', 'LSHandlers']);\n\n\t// `(?!-)` is to prevent matching `LSHandlerRoleAll = \"-\";`.\n\tconst match = /LSHandlerRoleAll = \"(?!-)(?<id>[^\"]+?)\";\\s+?LSHandlerURLScheme = (?:http|https);/.exec(stdout);\n\n\treturn match?.groups.id ?? 'com.apple.Safari';\n}\n", "import process from 'node:process';\nimport {promisify} from 'node:util';\nimport {execFile, execFileSync} from 'node:child_process';\n\nconst execFileAsync = promisify(execFile);\n\nexport async function runAppleScript(script, {humanReadableOutput = true} = {}) {\n\tif (process.platform !== 'darwin') {\n\t\tthrow new Error('macOS only');\n\t}\n\n\tconst outputArguments = humanReadableOutput ? [] : ['-ss'];\n\n\tconst {stdout} = await execFileAsync('osascript', ['-e', script, outputArguments]);\n\treturn stdout.trim();\n}\n\nexport function runAppleScriptSync(script, {humanReadableOutput = true} = {}) {\n\tif (process.platform !== 'darwin') {\n\t\tthrow new Error('macOS only');\n\t}\n\n\tconst outputArguments = humanReadableOutput ? [] : ['-ss'];\n\n\tconst stdout = execFileSync('osascript', ['-e', script, ...outputArguments], {\n\t\tencoding: 'utf8',\n\t\tstdio: ['ignore', 'pipe', 'ignore'],\n\t\ttimeout: 500,\n\t});\n\n\treturn stdout.trim();\n}\n", "import {runAppleScript} from 'run-applescript';\n\nexport default async function bundleName(bundleId) {\n\treturn runAppleScript(`tell application \"Finder\" to set app_path to application file id \"${bundleId}\" as string\\ntell application \"System Events\" to get value of property list item \"CFBundleName\" of property list file (app_path & \":Contents:Info.plist\")`);\n}\n", "import {promisify} from 'node:util';\nimport {execFile} from 'node:child_process';\n\nconst execFileAsync = promisify(execFile);\n\n// Windows doesn't have browser IDs in the same way macOS/Linux does so we give fake\n// ones that look real and match the macOS/Linux versions for cross-platform apps.\nconst windowsBrowserProgIds = {\n\tAppXq0fevzme2pys62n3e0fbqa7peapykr8v: {name: 'Edge', id: 'com.microsoft.edge.old'},\n\tMSEdgeDHTML: {name: 'Edge', id: 'com.microsoft.edge'}, // On macOS, it's \"com.microsoft.edgemac\"\n\tMSEdgeHTM: {name: 'Edge', id: 'com.microsoft.edge'}, // Newer Edge/Win10 releases\n\t'IE.HTTP': {name: 'Internet Explorer', id: 'com.microsoft.ie'},\n\tFirefoxURL: {name: 'Firefox', id: 'org.mozilla.firefox'},\n\tChromeHTML: {name: 'Chrome', id: 'com.google.chrome'},\n\tBraveHTML: {name: 'Brave', id: 'com.brave.Browser'},\n\tBraveBHTML: {name: 'Brave Beta', id: 'com.brave.Browser.beta'},\n\tBraveSSHTM: {name: 'Brave Nightly', id: 'com.brave.Browser.nightly'},\n};\n\nexport class UnknownBrowserError extends Error {}\n\nexport default async function defaultBrowser(_execFileAsync = execFileAsync) {\n\tconst {stdout} = await _execFileAsync('reg', [\n\t\t'QUERY',\n\t\t' HKEY_CURRENT_USER\\\\Software\\\\Microsoft\\\\Windows\\\\Shell\\\\Associations\\\\UrlAssociations\\\\http\\\\UserChoice',\n\t\t'/v',\n\t\t'ProgId',\n\t]);\n\n\tconst match = /ProgId\\s*REG_SZ\\s*(?<id>\\S+)/.exec(stdout);\n\tif (!match) {\n\t\tthrow new UnknownBrowserError(`Cannot find Windows browser in stdout: ${JSON.stringify(stdout)}`);\n\t}\n\n\tconst {id} = match.groups;\n\n\tconst browser = windowsBrowserProgIds[id];\n\tif (!browser) {\n\t\tthrow new UnknownBrowserError(`Unknown browser ID: ${id}`);\n\t}\n\n\treturn browser;\n}\n", "import { parseCmdLine } from \"./args.ts\";\nimport { signIn } from \"./signin.ts\";\n\nexport async function main(args: string[]): Promise<number> {\n  const command = parseCmdLine(args);\n  if (command.error) {\n    console.error(command.error);\n    return 1;\n  }\n  await signIn({\n    clientId: command.oidcClientId,\n    clientSecret: command.clientSecret,\n    port: command.port,\n  });\n  return 0;\n}\n"],
  "mappings": "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",
  "names": ["argv", "existsSync", "readFileSync", "parseArgs", "parseEnv", "parseCmdLine", "args", "parsed", "envPath", "env", "readEnvFile", "error", "oidcClientId", "oidClientSecret", "readEnvFile", "envFilePath", "buffer", "readFileSync", "parseEnv", "createServer", "InvalidTokenError", "b64DecodeUnicode", "str", "m", "p", "code", "base64UrlDecode", "output", "jwtDecode", "token", "options", "pos", "part", "decoded", "e", "nopLogger", "level", "logger", "Log", "reset", "setLevel", "value", "setLogger", "Logger", "_Logger", "_name", "args", "err", "method", "methodLogger", "name", "staticMethod", "staticLogger", "prefix", "JwtUtils", "token", "jwtDecode", "header", "payload", "privateKey", "encodedHeader", "CryptoUtils", "encodedPayload", "encodedToken", "signature", "encodedSignature", "UUID_V4_TEMPLATE", "toBase64", "val", "chr", "_CryptoUtils", "arr", "c", "code_verifier", "data", "hashed", "client_id", "client_secret", "alg", "message", "msgUint8", "hashBuffer", "jwk", "jsonObject", "utf8encodedAndHashed", "url", "accessToken", "httpMethod", "keyPair", "nonce", "hashedToken", "encodedHash", "publicJwk", "input", "Event", "cb", "idx", "ev", "Timer", "_Timer", "Event", "Logger", "diff", "durationInSeconds", "logger", "expiration", "timerDurationInSeconds", "UrlUtils", "url", "responseMode", "params", "URL_STATE_DELIMITER", "ErrorResponse", "args", "form", "_a", "_b", "_c", "ErrorTimeout", "message", "InMemoryWebStorage", "Logger", "key", "value", "index", "ErrorDPoPNonce", "nonce", "message", "JsonService", "additionalContentTypes", "_jwtHandler", "_extraHeaders", "input", "init", "timeoutInSeconds", "initFetch", "controller", "timeoutId", "err", "ErrorTimeout", "url", "token", "credentials", "logger", "headers", "response", "contentType", "item", "json", "ErrorResponse", "body", "basicAuth", "initCredentials", "extraHeaders", "responseText", "customKeys", "protectedHeaders", "preventOverride", "headerName", "content", "MetadataService", "_settings", "metadata", "optional", "name", "jwks_uri", "keySet", "WebStorageStateStore", "prefix", "store", "len", "keys", "DefaultResponseType", "DefaultScope", "DefaultClientAuthentication", "DefaultStaleStateAgeInSeconds", "OidcClientSettingsStore", "authority", "metadataUrl", "signingKeys", "metadataSeed", "client_id", "client_secret", "response_type", "scope", "redirect_uri", "post_logout_redirect_uri", "client_authentication", "prompt", "display", "max_age", "ui_locales", "acr_values", "resource", "response_mode", "filterProtocolClaims", "loadUserInfo", "requestTimeoutInSeconds", "staleStateAgeInSeconds", "mergeClaimsStrategy", "disablePKCE", "stateStore", "revokeTokenAdditionalContentTypes", "fetchRequestCredentials", "refreshTokenAllowedScope", "extraQueryParams", "extraTokenParams", "dpop", "omitScopeWhenRequesting", "_a", "UserInfoService", "_metadataService", "payload", "JwtUtils", "claims", "TokenClient", "grant_type", "args", "params", "CryptoUtils", "param", "ResponseValidator", "_claimsService", "state", "skipUserInfo", "shouldValidateSubClaim", "_b", "hasIdToken", "validateSub", "tokenResponse", "existingToken", "incoming", "existing", "State", "_State", "Timer", "storageString", "storage", "age", "cutoff", "i", "remove", "SigninState", "_SigninState", "code_verifier", "code_challenge", "data", "_SigninRequest", "state_data", "request_type", "url_state", "dpopJkt", "optionalParams", "parsedUrl", "stateParam", "URL_STATE_DELIMITER", "r", "SigninRequest", "OidcScope", "SigninResponse", "splitState", "SignoutRequest", "id_token_hint", "SignoutResponse", "DefaultProtocolClaims", "InternalRequiredProtocolClaims", "ClaimsService", "result", "protocolClaims", "claim", "claims1", "claims2", "values", "mergedValues", "DPoPState", "OidcClient", "settings", "metadataService", "request", "request_uri", "login_hint", "signinRequest", "signinState", "removeState", "UrlUtils", "storedStateString", "dpopProof", "dpopStore", "keyPair", "dpopState", "username", "password", "signinResponse", "allowableScopes", "s", "signoutState", "type", "process", "Buffer", "path", "fileURLToPath", "promisify", "childProcess", "fs", "fsConstants", "process", "fs", "fsConstants", "process", "os", "fs", "fs", "fs", "isDockerCached", "hasDockerEnv", "hasDockerCGroup", "isDocker", "cachedResult", "hasContainerEnv", "fs", "isInsideContainer", "isDocker", "isWsl", "process", "os", "isInsideContainer", "fs", "is_wsl_default", "wslDrivesMountPoint", "defaultMountPoint", "mountPoint", "configFilePath", "isConfigFileExists", "fs", "fsConstants", "configContent", "configMountPoint", "powerShellPathFromWsl", "powerShellPath", "is_wsl_default", "process", "defineLazyProperty", "object", "propertyName", "valueGetter", "define", "value", "result", "promisify", "process", "execFile", "promisify", "process", "execFile", "execFileAsync", "defaultBrowserId", "stdout", "process", "promisify", "execFile", "execFileSync", "execFileAsync", "runAppleScript", "script", "humanReadableOutput", "outputArguments", "stdout", "bundleName", "bundleId", "runAppleScript", "promisify", "execFile", "execFileAsync", "windowsBrowserProgIds", "UnknownBrowserError", "defaultBrowser", "_execFileAsync", "stdout", "match", "id", "browser", "execFileAsync", "promisify", "execFile", "titleize", "string", "x", "defaultBrowser", "process", "id", "defaultBrowserId", "bundleName", "stdout", "execFile", "promisify", "childProcess", "__dirname", "path", "fileURLToPath", "localXdgOpenPath", "platform", "arch", "process", "getWindowsDefaultBrowserFromWsl", "powershellPath", "powerShellPath", "rawCommand", "encodedCommand", "Buffer", "stdout", "progId", "browserMap", "pTryEach", "array", "mapper", "latestError", "item", "error", "baseOpen", "options", "singleApp", "app", "appArguments", "appName", "ids", "flags", "browser", "is_wsl_default", "defaultBrowser", "browserName", "apps", "command", "cliArguments", "childProcessOptions", "isInsideContainer", "encodedArguments", "argument", "isBundled", "exeLocalXdgOpen", "fs", "fsConstants", "subprocess", "resolve", "reject", "exitCode", "open", "target", "detectArchBinary", "binary", "arch", "archBinary", "detectPlatformBinary", "platform", "platformBinary", "wsl", "is_wsl_default", "apps", "defineLazyProperty", "open_default", "open", "signIn", "clientId", "clientSecret", "port", "client", "OidcClient", "request", "open_default", "res", "server", "runServer", "sleep", "re", "result", "createServer", "req", "ms", "main", "args", "command", "parseCmdLine", "signIn", "main", "argv", "exitCode"]
}
